<!DOCTYPE HTML>
<html lang="de" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Die Programmiersprache Rust</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Eine deutsche Gemeinschafts-Übersetzung des offiziellen Rust-Buchs.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="theme/ferris.css">
        
        <link rel="stylesheet" href="theme/2018-edition.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Die Programmiersprache Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Vorwort</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Einführung</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Erste Schritte</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hallo Welt</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hallo Cargo</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Ein Ratespiel programmieren</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Allgemeine Programmierkonzepte</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variablen und Veränderlichkeit</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Datentypen</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Funktionen</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Kommentare</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Kontrollfluss</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Eigentümerschaft (ownership) verstehen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Was ist Eigentümerschaft (ownership)?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referenzen und Ausleihen (borrowing)</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Der Anteilstyp (slice)</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Strukturen (structs) für zusammenhängende Daten verwenden</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Strukturen (structs) definieren und instanziieren</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Beispielprogramm mit Strukturen (structs)</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Methodensyntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Aufzählungen (enums) und Musterabgleich (pattern matching)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Eine Aufzählung (enum) definieren</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> Der Kontrollflussoperator match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Prägnanter Kontrollfluss mit if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Wachsende Projekte verwalten mit Paketen (packages), Kisten (crates) und Modulen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Pakete (packages) und Kisten (crates)</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Mit Modulen den Kontrollumfang und Datenschutz steuern</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Mit Pfaden auf ein Element im Modulbaum verweisen</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Pfade in den Gültigkeitsbereich bringen mit dem Schlüsselwort use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Module in verschiedene Dateien aufteilen</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Allgemeine Kollektionen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Wertlisten in Vektoren (vectors) ablegen</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> UTF-8-kodierten Text in Zeichenketten (strings) ablegen</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Schlüssel mit zugehörigen Werten in Hashtabellen ablegen</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Fehlerbehandlung</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unbehebbare Fehler mit panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Behebbare Fehler mit Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Wann panic! verwenden und wann nicht?</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generische Typen, Merkmale (traits) und Lebensdauer</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generische Datentypen</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Merkmale (traits): Gemeinsames Verhalten definieren</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Referenzen validieren mit Lebensdauern</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Automatisierte Tests schreiben</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Tests schreiben</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Steuern wie Tests ausgeführt werden</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Testverwaltung</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Ein E/A-Projekt: Ein Kommandozeilenprogramm erstellen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Kommandozeilenargumente entgegennehmen</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Eine Datei einlesen</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refaktorierung um die Modularität und Fehlerbehandlung zu verbessern</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Bibliotheksfunktionalität mit testgetriebener Entwicklung erstellen</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Mit Umgebungsvariablen arbeiten</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Fehlermeldungen in die Standardfehlerausgabe anstatt der Standardausgabe schreiben</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Funktionale Sprachelemente: Iteratoren und Funktionsabschlüsse (closures)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Funktionsabschlüsse (closures): Anonyme Funktionen die ihre Umgebung erfassen können</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Eine Reihe von Elementen verarbeiten mit Iteratoren</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Unser E/A-Projekt verbessern</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performanzvergleich: Schleifen vs. Iteratoren</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Mehr über Cargo und Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Bauvorgang anpassen mit Freigabeprofilen (release profiles)</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Kisten (crate) auf crates.io veröffentlichen</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo-Arbeitsbereiche</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Kommandozeilenwerkzeuge von crates.io installieren mit cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Cargo um benutzerdefinierte Befehle erweitern</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Intelligente Zeiger</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Mit Box<T> auf Daten im dynamischen Speicher zeigen</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Intelligente Zeiger wie normale Referenzen behandeln mit dem Merkmal (trait) Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Programmcode beim Aufräumen ausführen mit dem Merkmal (trait) Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Der referenzzählende intelligente Zeiger Rc<T></a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell<T> und das innere Veränderlichkeitsmuster</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Referenzzyklen können zu einem Speicherleck führen</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Furchtlose Nebenläufigkeit</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Mit Prozessen (threads) Programmcode gleichzeitig ausführen</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Nachrichtenaustausch zwischen Prozessen (threads)</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Nebenläufigkeit mit gemeinsamem Zustand</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Erweiterbare Nebenläufigkeit mit den Merkmalen (traits) Sync und Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Objektorientierte Sprachelemente von Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Charakteristika objektorientierter Sprachen</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Merkmalsobjekte (trait objects) die Werte unterschiedlicher Typen erlauben</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Ein objektorientiertes Entwurfsmuster implementieren</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Muster (patterns) und Abgleich (matching)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Alle Stellen an denen Muster (patterns) verwendet werden können</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Widerlegbarkeit: Falls ein Muster (pattern) mal nicht passt</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Mustersyntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Fortgeschrittene Sprachelemente</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsicheres (unsafe) Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Fortgeschrittene Merkmale (traits)</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Fortgeschrittene Typen</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Erweiterte Funktionen und Funktionsabschlüsse (closures)</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Makros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Abschlussprojekt: Einen mehrsträngigen (multi-threaded) Webserver erstellen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Einen einsträngigen (single-threaded) Webserver erstellen</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Unseren einsträngigen (single-threaded) Webserver in einen mehrsträngigen (multi-threaded) Webserver verwandeln</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Kontrolliertes Beenden und Aufräumen</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Anhang</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Schlüsselwörter</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operatoren und Symbole</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Ableitbare Merkmale (traits)</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Nützliche Entwicklungswerkzeuge</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Ausgaben</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Übersetzungen des Buchs</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Wie Rust erstellt wird und “nächtliches Rust”</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                    </div>

                    <h1 class="menu-title">Die Programmiersprache Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/rust-lang-de/rustbook-de" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#die-programmiersprache-rust" id="die-programmiersprache-rust">Die Programmiersprache Rust</a></h1>
<p><em>von Steve Klabnik und Carol Nichols, unter Mitarbeit der Rust-Gemeinschaft</em></p>
<p>Diese Version des Textes geht davon aus, dass du Rust 1.41.0 oder später mit
<code>edition=&quot;2018&quot;</code> in <em>Cargo.toml</em> in allen Projekten verwendest, um Rust 2018
Idiome zu verwenden. Siehe <a href="ch01-01-installation.html">Abschnitt „Installation“</a> zum Installieren
und Aktualisieren von Rust sowie <a href="appendix-05-editions.html">Anhang E</a> zu Informationen zu den
Ausgaben.</p>
<p>Ausgabe 2018 von Rust enthält einige Verbesserungen, die Rust ergonomischer und
einfacher zu lernen machen. Diese Fassung des Buchs enthält eine Reihe von
Änderungen, die diese Verbesserungen widerspiegeln:</p>
<ul>
<li>Kapitel 7 „Wachsende Projekte verwalten mit Paketen (packages), Kisten
(crates) und Modulen“ wurde größtenteils umgeschrieben. Das Modulsystem und
die Funktionsweise der Pfade in Ausgabe 2018 wurden konsistenter gestaltet.</li>
<li>Kapitel 10 hat die neuen Abschnitte „Merkmale als Parameter“ und
„Rückgabetypen die Merkmale implementieren“, die die neue Syntax von
<code>impl Trait</code> erklären.</li>
<li>Kapitel 11 hat einen neuen Abschnitt „Verwenden von <code>Result&lt;T, E&gt;</code> in Tests“,
der zeigt, wie man Tests schreibt, die den Operator <code>?</code> verwenden.</li>
<li>Der Abschnitt „Fortgeschrittene Lebensdauern“ in Kapitel 19 wurde entfernt,
weil die verwendeten Konstrukte durch Kompilierer-Verbesserungen noch
seltener geworden sind.</li>
<li>Der frühere Anhang D „Makros“ wurde um prozedurale Makros erweitert und in
den Abschnitt „Makros“ in Kapitel 19 verschoben.</li>
<li>Anhang A „Schlüsselwörter“ erläutert auch die neue Funktionalität der rohen
Bezeichner, die es ermöglicht, dass in Ausgabe 2015 und in Ausgabe 2018
geschriebener Programmcode zusammen verwendet werden kann.</li>
<li>Anhang D trägt jetzt den Titel „Nützliche Entwicklungswerkzeuge“ und umfasst
kürzlich veröffentlichte Werkzeuge, die dir beim Schreiben von Rust-Code
helfen.</li>
<li>Wir haben im gesamten Buch etliche kleine Fehler und unpräzise Formulierungen
korrigiert. Vielen Dank an die Leser, die sie gemeldet haben!</li>
</ul>
<p>Beachte, dass jeder kompilierbare Programmcode aus früheren Fassungen des Buchs
weiterhin kompiliert, wenn <code>edition=&quot;2018&quot;</code> nicht in <em>Cargo.toml</em> des Projekts
nicht angegeben wird, selbst wenn du die verwendete Rust-Kompilierer-Version
aktualisierst. Das ist die Rückwärtskompatibilitätsgarantie von Rust!</p>
<p>Die HTML-Version ist online verfügbar unter
https://doc.rust-lang.org/stable/book/ (englisches Original) und
https://rust-lang-de.github.io/rustbook-de/ (deutsche Übersetzung).
Wenn die Rust-Installation mit <code>rustup</code> erfolgt ist, kann das Buch offline mit
<code>rustup docs --book</code> geöffnet werden (nur in Englisch).</p>
<p>Der englische Text ist auch als <a href="https://nostarch.com/rust">Taschenbuch und E-Book bei No Starch
Press</a> erhältlich.</p>
<h1><a class="header" href="#vorwort" id="vorwort">Vorwort</a></h1>
<p>Es war nicht immer so klar, aber bei der Programmiersprache Rust geht es im
Grunde um <em>Befähigung</em>: Egal, welche Art von Kode du jetzt schreibst, Rust
befähigt dich dazu, weiter zu gehen, mit Vertrauen in einer größeren Vielfalt
von Bereichen zu programmieren, als du es zuvor getan hast.</p>
<p>Denken wir zum Beispiel an systemnahe Arbeiten, bei denen Details wie
Speicherverwaltung, Datenrepräsentation und Nebenläufigkeit wichtig sind.
Traditionellerweise gilt dieser Bereich der Programmierung als geheimnisvoll
und nur wenigen Auserwählten zugänglich, die die erforderliche Erfahrung
gesammelt haben, um berüchtigte Fallstricke vermeiden zu können. Und selbst
diejenigen, die damit arbeiten, tun dies mit Sorgfalt, damit ihr Kode nicht
angreifbar ist, abstürzt oder fehlerhaft ist.</p>
<p>Rust baut diese Barrieren ab, indem es die alten Fallstricke beseitigt und ein
freundliches, ausgefeiltes Instrumentarium zur Verfügung stellt, das dich auf
deinem Weg unterstützt. Programmierer, die in die systemnahen Kontrollebenen
„eintauchen“ müssen, können dies mit Rust tun, ohne das übliche Risiko von
Abstürzen oder Sicherheitslücken einzugehen und ohne die Finessen einer
wankelmütigen Werkzeugkette erlernen zu müssen. Besser noch, die Sprache ist so
konzipiert, dass sie dich auf natürliche Weise zu zuverlässigem Code führt, der
effizient in Bezug auf Geschwindigkeit und Speichernutzung ist.</p>
<p>Programmierer, die bereits mit systemnahem Code arbeiten, können Rust nutzen,
um ihre Ambitionen zu steigern. Beispielsweise ist die Einführung von
Parallelität in Rust ein relativ risikoarmes Unterfangen: Der Compiler fängt
die klassischen Fehler für dich ab. Und du kannst aggressivere Optimierungen in
deinem Kode wagen mit der Gewissheit, keine versehentlichen Abstürze oder
Verwundbarkeiten einführen.</p>
<p>Aber Rust ist nicht auf systemnahe Programmierung beschränkt. Es ist
ausdrucksstark und ergonomisch genug, um das Schreiben von
Kommandozeilen-Anwendungen, Webservern und vielen anderen Arten an Kode recht
angenehm zu machen – du wirst später in diesem Buch einfache Beispiele
dazu finden. Die Arbeit mit Rust ermöglicht es dir, Fähigkeiten zu entwickeln,
die von einer Domäne auf eine andere übertragen werden können; du kannst Rust
durch Schreiben einer Webanwendung erlernen und dann diese Fähigkeiten auf
deinen Raspberry Pi anwenden.</p>
<p>In diesem Buch wird das Potenzial von Rust zur Befähigung seiner Nutzer voll
ausgeschöpft. Es ist ein freundlicher und zugänglicher Text, der dir helfen
soll, nicht nur dein Wissen über Rust zu erweitern, sondern auch deine
Reichweite und dein Selbstvertrauen als Programmierer im Allgemeinen. Also
tauche ein, mach dich bereit zum Lernen – und willkommen in der
Rust-Gemeinschaft!</p>
<p>– Nicholas Matsakis und Aaron Turon</p>
<h1><a class="header" href="#einführung" id="einführung">Einführung</a></h1>
<p>Willkommen bei <em>Die Programmiersprache Rust</em>, einem einführenden Buch über
Rust. Die Programmiersprache Rust hilft dir, schnellere und zuverlässigere
Software zu schreiben. Ergonomie und systemnahe Kontrolle stehen beim Entwurf
von Programmiersprachen oft im Widerspruch – Rust stellt sich diesem
Konflikt. Durch den Ausgleich zwischen leistungsstarken, technischen
Möglichkeiten und einer großartigen Entwicklererfahrung bietet dir Rust die
Möglichkeit, Details systemnah (z.B. Speichernutzung) zu kontrollieren, ohne
den ganzen Ärger, der damit typischerweise einhergeht.</p>
<h2><a class="header" href="#für-wen-rust-ist" id="für-wen-rust-ist">Für wen Rust ist</a></h2>
<p>Rust ist für viele Menschen aus einer Vielzahl von Gründen ideal. Schauen wir
uns einige der wichtigsten Nutzergruppen an.</p>
<h3><a class="header" href="#entwicklerteams" id="entwicklerteams">Entwicklerteams</a></h3>
<p>Rust erweist sich als produktives Werkzeug in der Zusammenarbeit großer
Entwicklerteams mit unterschiedlichem Kenntnisstand in der
Systemprogrammierung. Systemnaher Code ist anfällig für eine Vielzahl subtiler
Fehler, die in den meisten anderen Sprachen nur durch ausgiebige Tests und
sorgfältige Überprüfung des Codes durch erfahrene Entwickler erkannt werden
können. In Rust spielt der Kompilierer eine Art Pförtnerrolle, indem er Code
mit diesen schwer fassbaren Fehlern verweigert zu kompilieren, darunter auch
Nebenläufigkeitsfehler. Mit der Arbeit an der Seite des Kompilierers kann sich
das Team auf die Programmlogik konzentrieren anstatt Fehler zu suchen.</p>
<p>Rust bringt auch zeitgemäße Entwicklerwerkzeuge in die Welt der
Systemprogrammierung:</p>
<ul>
<li>Cargo, das mitgelieferte Abhängigkeitsmanagement- und Bau-Werkzeug, macht das
Hinzufügen, Kompilieren und Verwalten von Abhängigkeiten im gesamten
Rust-Ökosystem schmerzlos und konsistent.</li>
<li>Rustfmt gewährleistet einen einheitlichen Codierstil aller Entwickler.</li>
<li>Der Rust Sprachdienst (Language Server) ermöglicht Code-Vervollständigung und
im Code angezeigte Fehlermeldungen innerhalb der Entwicklungsumgebung (IDE).</li>
</ul>
<p>Durch den Einsatz dieser und anderer Werkzeuge des Rust-Ökosystems können
Entwickler produktiv arbeiten, während sie Code auf Systemebene schreiben.</p>
<h3><a class="header" href="#studenten" id="studenten">Studenten</a></h3>
<p>Rust ist für Studenten und alle, die sich für Systemkonzepte interessieren. Mit
Rust haben viele Menschen etwas über Themen wie die Entwicklung von
Betriebssystemen gelernt. Die Gemeinschaft ist sehr einladend und beantwortet
gerne Fragen der Studenten. Durch Bemühungen wie dieses Buch will das Rust-Team
Systemkonzepte mehr Menschen zugänglich machen, insbesondere denen, die neu in
der Programmierung sind.</p>
<h3><a class="header" href="#unternehmen" id="unternehmen">Unternehmen</a></h3>
<p>Hunderte von Unternehmen, große und kleine, setzen Rust für eine Vielzahl von
Aufgaben in der Produktion ein. Zu diesen Aufgaben gehören
Kommandozeilenwerkzeuge, Webdienste, DevOps-Werkzeuge, eingebettete Geräte,
Audio- und Videoanalyse und -transkodierung, Kryptowährungen, Bioinformatik,
Suchmaschinen, Anwendungen für das Internet der Dinge, maschinelles Lernen und
sogar wesentliche Teile des Webbrowsers Firefox.</p>
<h3><a class="header" href="#open-source-entwickler" id="open-source-entwickler">Open-Source-Entwickler</a></h3>
<p>Rust ist für Menschen, die die Programmiersprache Rust, die Gemeinschaft,
Entwickler-Werkzeuge und Bibliotheken aufbauen möchten. Wir würden uns freuen,
wenn du zur Programmiersprache Rust beiträgst.</p>
<h3><a class="header" href="#menschen-die-geschwindigkeit-und-stabilität-schätzen" id="menschen-die-geschwindigkeit-und-stabilität-schätzen">Menschen, die Geschwindigkeit und Stabilität schätzen</a></h3>
<p>Rost ist für Menschen, die sich nach Schnelligkeit und Stabilität einer Sprache
sehnen. Unter Geschwindigkeit verstehen wir die Geschwindigkeit der Programme,
die du mit Rust schreiben kannst, und die Geschwindigkeit, mit der dich Rust
diese Programme schreiben lässt. Die Prüfungen des Rust-Kompilierers
gewährleisten Stabilität während du neue Funktionen hinzufügst und deinen Code
änderst. Dies steht im Gegensatz zu brüchigen Code-Altlasten in Sprachen ohne
diese Prüfungen, die Entwickler oft scheuen modifizieren zu müssen. Durch das
Streben nach kostenneutralen Abstraktionen, also Funktionalität auf höherer
Ebene, die zu genauso schnellem Code wie manuell geschriebener Code auf
niedrigerer Ebene kompiliert, bemüht sich Rust, sicheren Code auch zu schnellem
Code zu machen.</p>
<p>Die Sprache Rust hofft, auch viele andere Nutzer zu unterstützen; die hier
genannten sind nur einige der größten Interessensgruppen. Insgesamt ist es
Rusts größtes Bestreben, den Zielkonflikt zu beseitigen, den Programmierer
jahrzehntelang hingenommen haben, wenn sie Sicherheit <em>und</em> Produktivität bzw.
Geschwindigkeit <em>und</em> Ergonomie erreichen wollten. Versuche es mit Rust und
finde heraus, ob dessen Möglichkeiten für dich geeignet sind.</p>
<h2><a class="header" href="#für-wen-dieses-buch-gedacht-ist" id="für-wen-dieses-buch-gedacht-ist">Für wen dieses Buch gedacht ist</a></h2>
<p>In diesem Buch wird davon ausgegangen, dass du bereits Code in einer anderen
Programmiersprache geschrieben hast, es spielt aber keine Rolle in welcher. Wir
haben versucht, das Material einem breiten Publikum mit unterschiedlichem
Programmierhintergrund zugänglich zu machen. Wir verbringen nicht viel Zeit
damit, darüber zu sprechen, was Programmieren <em>ist</em> oder wie man darüber denkt.
Wenn Programmieren für dich ganz neu ist, wäre es besser, wenn du ein Buch
speziell zur Einführung in die Programmierung liest.</p>
<h2><a class="header" href="#wie-man-dieses-buch-verwendet" id="wie-man-dieses-buch-verwendet">Wie man dieses Buch verwendet</a></h2>
<p>Im Allgemeinen geht dieses Buch davon aus, dass du es der Reihe nach von vorne
nach hinten lesen. Spätere Kapitel bauen auf den Konzepten früherer Kapitel
auf. Frühere Kapitel gehen möglicherweise nicht in die Einzelheiten eines
Themas ein, denn in der Regel werden wir es in einem späteren Kapitel erneut
aufgreifen.</p>
<p>Du findest in diesem Buch zwei Kapitelarten: Konzeptkapitel und
Projektkapitel. In Konzeptkapiteln erfährst du etwas über einen Aspekt von
Rust. In Projektkapiteln schreiben wir gemeinsam kleine Programme und wenden
das bisher Gelernte an. Die Kapitel 2, 12 und 20 sind Projektkapitel; die
übrigen sind Konzeptkapitel.</p>
<p>Kapitel 1 erklärt, wie man Rust installiert, wie man ein „Hallo Welt“-Programm
schreibt und wie man Cargo, den Paketmanager und das Bauwerkzeug von Rust,
benutzt. Kapitel 2 ist eine praktische Einführung in die Sprache Rust. Hier
werden Konzepte auf hohem Niveau behandelt, spätere Kapitel werden zusätzliche
Einzelheiten liefern. Wenn du dir schon jetzt die Hände schmutzig machen
willst, dann ist Kapitel 2 der richtige Ort dafür. Zunächst willst du
vielleicht sogar Kapitel 3 überspringen, in dem es um Rust-Funktionen geht, die
denen anderer Programmiersprachen ähneln, und direkt zu Kapitel 4 übergehen, um
mehr über den Eigentümerschaftsansatz von Rust zu erfahren. Wenn du jedoch ein
besonders akribischer Lerner bist, der lieber erst jedes Detail lernen will,
bevor er zum nächsten übergeht, willst du vielleicht Kapitel 2 überspringen und
direkt zu Kapitel 3 gehen und danach zu Kapitel 2 zurückkehren, um dann an
einem Projekt zu arbeiten und die gelernten Details anzuwenden.</p>
<p>Kapitel 5 bespricht Strukturen und Methoden, und Kapitel 6 behandelt
Aufzählungen, <code>match</code>-Ausdrücke und das <code>if let</code>-Kontrollflusskonstrukt. Du
wirst Strukturen und Aufzählungen verwenden, um benutzerdefinierte Typen in
Rust zu erstellen.</p>
<p>In Kapitel 7 erfährst du mehr über das Modulsystem von Rust und über die
Datenschutzregeln zum Organisieren deines Codes und dessen öffentlich
zugängliche Programmierschnittstelle (API). In Kapitel 8 werden einige gängige
Kollektionsdatenstrukturen, die die Standardbibliothek zur Verfügung stellt,
behandelt, z.B. Vektoren, Zeichenketten und Hashtabellen. Kapitel 9 befasst
sich mit Rusts Philosophie und Techniken der Fehlerbehandlung.</p>
<p>Kapitel 10 vertieft generische Datentypen, Merkmale und Lebensdauern, die dir
die Möglichkeit geben, Code zu schreiben, der für mehrere Typen passt. In
Kapitel 11 dreht sich alles um das Testen, das selbst mit den
Sicherheitsgarantien von Rust erforderlich ist, um eine korrekte Logik deines
Programms sicherzustellen. In Kapitel 12 werden wir unsere eigene
Implementierung für eine Teilfunktionalität des Kommandozeilenwerkzeugs <code>grep</code>
schreiben, das nach Text in Dateien sucht. Dazu werden wir viele Konzepte
anwenden, die wir in den vorangegangenen Kapiteln kennengelernt haben.</p>
<p>Kapitel 13 befasst sich mit Funktionsabschlüssen und Iteratoren, also
Sprachmerkmalen, die von funktionalen Programmiersprachen stammen. In Kapitel
14 werden wir einen genaueren Blick auf Cargo werfen und über bewährte
Vorgehensweisen beim Bereitstellen deiner Bibliotheken für andere sprechen. In
Kapitel 15 werden intelligente Zeiger, die die Standardbibliothek bereitstellt,
und Merkmale, die ihre Funktionalität ermöglichen, erörtert.</p>
<p>In Kapitel 16 gehen wir durch verschiedene Modelle der nebenläufigen
Programmierung und sprechen darüber, wie Rust dir hilft, furchtlos mit mehreren
Strängen zu programmieren. Kapitel 17 befasst sich mit dem Vergleich zwischen
Rust-Idiomen und den Prinzipien der objektorientierten Programmierung, mit
denen du vielleicht vertraut bist.</p>
<p>Kapitel 18 ist ein Nachschlagewerk zu Muster und Musterabgleich, einem
mächtigen Mittel zum Ausdrücken von Ideen in Rust-Programmen. Kapitel 19
enthält ein Sammelsurium an interessanten fortgeschrittenen Themen, darunter
unsicheres Rust, Makros und mehr zu Lebensdauer, Merkmalen, Typen, Funktionen
und Funktionsabschlüssen.</p>
<p>In Kapitel 20 werden wir ein Projekt abschließen, bei dem wir einen
systemnahen, nebenläufigen Webdienst implementieren!</p>
<p>Schließlich enthalten einige Anhänge nützliche Informationen über die Sprache
in einem eher referenzartigen Format. Anhang A enthält die Schlüsselwörter von
Rust, Anhang B die Operatoren und Symbole von Rust, Anhang C ableitbare
Merkmalen, die von der Standardbibliothek mitgebracht werden, Anhang D
nützliche Entwicklungswerkzeuge und Anhang E erläutert die Rust-Editionen.</p>
<p>Es gibt keinen falschen Weg, dieses Buch zu lesen: Wenn du was überspringen
willst, nur zu! Möglicherweise musst du zu früheren Kapiteln zurückkehren, wenn
du irritiert bist. Aber tue was immer für dich passt.</p>
<p><span id="ferris"></span></p>
<p>Ein wichtiger Teil beim Lernen von Rust ist das Verstehen der Fehlermeldungen,
die der Kompilierer anzeigt: Diese leiten dich zum funktionierenden Code. Daher
werden wir viele Beispiele bringen, die nicht kompilieren, zusammen mit der
jeweiligen Fehlermeldung des Kompilierers. Wenn du also ein zufälliges Beispiel
eingibst und ausführen willst, lässt es sich möglicherweise nicht kompilieren!
Stelle sicher, dass du den umgebenden Text liest, um zu wissen, ob das
Beispiel, das du ausführen willst, für einen Fehler gedacht ist. Ferris gibt
dir einen Hinweis bei Code, der nicht funktionieren soll:</p>
<table><thead><tr><th>Ferris</th><th>Bedeutung</th></tr></thead><tbody>
<tr><td><img src="img/ferris/does_not_compile.svg" class="ferris-explain"/></td><td>Dieser Code lässt sich nicht kompilieren!</td></tr>
<tr><td><img src="img/ferris/panics.svg" class="ferris-explain"/></td><td>Dieser Code bricht ab (panic)!</td></tr>
<tr><td><img src="img/ferris/unsafe.svg" class="ferris-explain"/></td><td>Dieser Codeblock enthält unsicheren Code.</td></tr>
<tr><td><img src="img/ferris/not_desired_behavior.svg" class="ferris-explain"/></td><td>Dieser Code liefert nicht das gewünschte Verhalten.</td></tr>
</tbody></table>
<p>In den meisten Situationen führen wir dich zu einer funktionierenden
Codeversion, wenn er sich nicht kompilieren lässt.</p>
<h2><a class="header" href="#quellcode" id="quellcode">Quellcode</a></h2>
<p>Die Quelldateien, aus denen dieses Buch generiert wird, findest du unter
<a href="https://github.com/rust-lang-de/rustbook-de/tree/master/src">GitHub</a>.</p>
<h1><a class="header" href="#eigentümerschaft-ownership-verstehen" id="eigentümerschaft-ownership-verstehen">Eigentümerschaft (ownership) verstehen</a></h1>
<p>Eigentümerschaft (ownership) ist das wichtigste Alleinstellungsmerkmal von
Rust, und sie ermöglicht es Rust, Speichersicherheitsgarantien ohne Einsatz
einer automatischen Speicherbereinigung (garbage collector) zu geben. Deshalb
ist es wichtig zu verstehen, wie Eigentümerschaft in Rust funktioniert. In
diesem Kapitel werden wir uns neben der Eigentümerschaft weitere diesbezügliche
Funktionalitäten ansehen: Ausleihen (borrowing), Anteilstypen (slices) und wie
Rust Daten im Speicher anordnet.</p>
<h2><a class="header" href="#was-ist-eigentümerschaft-ownership" id="was-ist-eigentümerschaft-ownership">Was ist Eigentümerschaft (ownership)?</a></h2>
<p>Die zentrale Funktionalität von Rust ist <em>Eigentümerschaft</em> (ownership). Obwohl
diese Funktionalität einfach zu erklären ist, hat sie weitgehende Auswirkungen
auf den Rest der Sprache.</p>
<p>Alle Programme müssen den Arbeitsspeicher eines Rechners verwalten, während sie
ausgeführt werden. Einige Sprachen verfügen über eine automatische
Speicherbereinigung, die während der Programmausführung ständig nach nicht mehr
genutztem Speicher sucht. Bei anderen Sprachen muss der Programmierer selbst
den Speicher explizit reservieren und freigeben. Rust verwendet einen dritten
Ansatz: Der Speicher wird durch ein System aus Eigentümerschaft und einer Reihe
von Regeln verwaltet, die der Kompilierer zur Kompilierzeit überprüft. Keine
der Eigentümerschaftsfunktionalitäten verlangsamt dein Programm, während es
läuft.</p>
<p>Da die Eigentümerschaft für viele Programmierer ein neues Konzept ist, braucht
es etwas Zeit, sich daran zu gewöhnen. Die gute Nachricht ist, je mehr
Erfahrung du mit Rust und den Regeln der Eigentümerschaft gesammelt hast, desto
mehr kannst du auf natürliche Weise Code entwickeln, der sicher und effizient
ist. Bleib dran!</p>
<p>Wenn du Eigentümerschaft verstehst, hast du eine solide Grundlage, um die
Funktionalitäten zu verstehen, die Rust einzigartig machen. In diesem Kapitel
lernst du Eigentümerschaft kennen, indem du einige Beispiele durcharbeitest,
die sich auf eine sehr verbreitete Datenstruktur konzentrieren: Zeichenketten
(strings).</p>
<blockquote>
<h3><a class="header" href="#stapelspeicher-stack-und-dynamischer-speicher-heap" id="stapelspeicher-stack-und-dynamischer-speicher-heap">Stapelspeicher (stack) und dynamischer Speicher (heap)</a></h3>
<p>In vielen Programmiersprachen musst du nicht sehr oft über Stapelspeicher und
dynamischen Speicher nachdenken. Aber in einer Systemprogrammiersprache wie
Rust hat die Frage, ob ein Wert auf dem Stapelspeicher oder im dynamischen
Speicher liegt, einen größeren Einfluss darauf, wie sich die Sprache verhält
und warum du bestimmte Entscheidungen treffen musst. Teile der
Eigentümerschaft werden später in diesem Kapitel in Bezug auf den
Stapelspeicher und den dynamischen Speicher beschrieben, daher hier eine
kurze Erklärung zur Vorbereitung.</p>
<p>Sowohl Stapelspeicher als auch dynamischer Speicher sind Teile des
Arbeitsspeichers, die deinem Code zur Laufzeit zur Verfügung stehen, aber sie
sind unterschiedlich strukturiert. Der Stapelspeicher speichert Werte in der
Reihenfolge, in der er sie erhält, und entfernt die Werte in umgekehrter
Reihenfolge. Dies wird als <em>zuletzt herein, zuerst hinaus</em> (last in, first
out) bezeichnet. Denke an einen Stapel Teller: Wenn du weitere Teller
hinzufügst, legst du sie auf den Stapel, und wenn du einen Teller benötigst,
nimmst du einen von oben. Das Hinzufügen oder Entfernen von Tellern aus der
Mitte oder von unten würde nicht so gut funktionieren! Das Hinzufügen von
Daten nennt man <em>auf den Stapel legen</em>, und das Entfernen von Daten nennt man
<em>vom Stapel nehmen</em>.</p>
<p>Alle im Stapelspeicher gespeicherten Daten müssen eine bekannte, feste Größe
haben. Daten mit einer zur Kompilierzeit unbekannten Größe oder einer Größe,
die sich ändern könnte, müssen stattdessen im dynamischen Speicher
gespeichert werden. Der dynamische Speicher ist weniger organisiert: Wenn du
Daten in den dynamischen Speicher legst, forderst du eine bestimmte Menge an
Speicherplatz an. Das Betriebssystem sucht eine leere Stelle im dynamischen
Speicher, die groß genug ist, markiert sie als in Benutzung und gibt einen
<em>Zeiger</em> (pointer) zurück, der die Adresse dieser Stelle ist. Dieser Vorgang
wird als <em>Allokieren im dynamischen Speicher</em> bezeichnet und manchmal mit
<em>Allokieren</em> abgekürzt. Das Legen von Werten auf den Stapelspeicher gilt
nicht als Allokieren. Da es sich beim Zeiger um eine bekannte, feste Größe
handelt, kannst du den Zeiger auf den Stapelspeicher legen, aber wenn du die
eigentlichen Daten benötigst, musst du dem Zeiger folgen.</p>
<p>Stell dir vor, du sitzst in einem Restaurant. Wenn du hineingehst, gibst du
die Anzahl der Personen deiner Gruppe an, und das Personal findet einen
leeren Tisch, der groß genug ist, und führt euch dorthin. Wenn jemand aus
deiner Gruppe zu spät kommt, kann er fragen, wo ihr Platz genommen habt, um
euch zu finden.</p>
<p>Das Legen auf den Stapelspeicher ist schneller als das Allokieren im
dynamischen Speicher, da das Betriebssystem nie nach Platz zum Speichern
neuer Daten suchen muss; dieser Ort ist immer ganz oben auf dem Stapel. Im
Vergleich dazu erfordert das Allokieren von Speicherplatz im dynamischen
Speicher mehr Arbeit, da das Betriebssystem zunächst einen ausreichend großen
Platz für die Daten finden und dann Buch führen muss, um die nächste
Allokation vorzubereiten.</p>
<p>Der Zugriff auf Daten im dynamischen Speicher ist langsamer als der Zugriff
auf Daten auf dem Stapelspeicher, da du einem Zeiger folgen musst, um dorthin
zu gelangen. Heutige Prozessoren sind schneller, wenn sie weniger im Speicher
herumspringen. Um die Analogie fortzusetzen, betrachte einen Kellner in einem
Restaurant, der an vielen Tischen Bestellungen aufnimmt. Es ist am
effizientesten, alle Bestellungen an einem Tisch aufzunehmen, bevor man zum
nächsten Tisch weitergeht. Eine Bestellung von Tisch A, dann eine Bestellung
von Tisch B, dann wieder eine von A und dann wieder eine von B aufzunehmen,
wäre ein viel langsamerer Vorgang. Umgekehrt kann ein Prozessor seine Arbeit
besser erledigen, wenn er mit Daten arbeitet, die nahe beieinander liegen
(wie sie auf dem Stapelspeicher liegen) und nicht weiter voneinander entfernt
(wie sie im dynamischen Speicher liegen können). Das Allokieren einer großen
Menge an Platz im dynamischen Speicher kann ebenfalls Zeit in Anspruch
nehmen.</p>
<p>Wenn dein Code eine Funktion aufruft, werden die an die Funktion übergebenen
Werte (einschließlich potentieller Zeiger auf Daten im dynamischen Speicher)
und die lokalen Variablen der Funktion auf den Stapelspeicher gelegt. Wenn
die Funktion beendet ist, werden diese Werte vom Stapelspeicher genommen.</p>
<p>Das Nachverfolgen, welche Codeteile welche Daten im dynamischen Speicher
verwenden, das Minimieren der Menge an doppelten Daten im dynamischen
Speicher und das Aufräumen ungenutzter Daten im dynamischen Speicher, damit
dir der Speicherplatz nicht ausgeht, sind alles Probleme, die durch
Eigentümerschaft gelöst werden. Wenn du Eigentümerschaft einmal verstanden
hast, brauchst du nicht mehr so oft über Stapelspeicher und dynamischen
Speicher nachzudenken. Aber zu wissen, dass die Verwaltung von dynamischen
Speicherdaten der Grund für Eigentümerschaft ist, kann helfen zu erklären,
warum es so funktioniert, wie es funktioniert.</p>
</blockquote>
<h3><a class="header" href="#eigentumsregeln" id="eigentumsregeln">Eigentumsregeln</a></h3>
<p>Lass uns zunächst einen Blick auf die Eigentumsregeln (ownership rules) werfen.
Behalte diese Regeln im Hinterkopf, während wir veranschaulichende Beispiele
durcharbeiten:</p>
<ul>
<li>Jeder Wert in Rust hat eine Variable, die als sein <em>Eigentümer</em> bezeichnet
wird.</li>
<li>Es kann immer nur einen Eigentümer zur gleichen Zeit geben.</li>
<li>Wenn der Eigentümer den Gültigkeitsbereich verlässt, wird der Wert gelöscht.</li>
</ul>
<h3><a class="header" href="#gültigkeitsbereich-scope-einer-variable" id="gültigkeitsbereich-scope-einer-variable">Gültigkeitsbereich (scope) einer Variable</a></h3>
<p>Wir sind bereits in Kapitel 2 ein Beispiel für ein Rust-Programm durchgegangen.
Da wir nun über die grundlegende Syntax hinausgehen, werden wir nicht mehr den
gesamten <code>fn main() {</code>-Code in die Beispiele aufnehmen. Wenn du also
weitermachst, musst du die folgenden Beispiele manuell in eine Funktion <code>main</code>
einfügen. Folglich werden unsere Beispiele etwas prägnanter sein, damit wir uns
auf die eigentlichen Details konzentrieren können, anstatt auch den Code darum
herum betrachten zu müssen.</p>
<p>Als erstes Beispiel zu Eigentümerschaft werden wir uns den <em>Gültigkeitsbereich</em>
(scope) einiger Variablen ansehen. Der Gültigkeitsbereich ist der Bereich
innerhalb eines Programms, in dem ein Element gültig ist. Nehmen wir an, wir
haben eine Variable, die so aussieht:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s = &quot;Hallo&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>Die Variable <code>s</code> bezieht sich auf ein Zeichenkettenliteral, wobei der Wert der
Zeichenkette fest in den Text unseres Programms kodiert ist. Die Variable ist
ab der Stelle, an der sie deklariert wurde, bis zum Ende des aktuellen
<em>Gültigkeitsbereichs</em> gültig. Codeblock 4-1 enthält Kommentare mit Anmerkungen,
wo die Variable <code>s</code> gültig ist.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>{                      // s ist hier nicht gültig, es wurde noch nicht deklariert
    let s = &quot;Hallo&quot;;   // s ist ab dieser Stelle gültig

    // etwas mit s machen
}                      // dieser Gültigkeitsbereich ist nun vorbei,
                       // und s ist nicht mehr gültig
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 4-1: Eine Variable und der Bereich, in dem sie
gültig ist</span></p>
<p>Mit anderen Worten, es gibt hier zwei wichtige Zeitpunkte:</p>
<ul>
<li>Wenn <code>s</code> <em>in den Gültigkeitsbereich</em> kommt, ist es gültig.</li>
<li>Es bleibt gültig, bis es <em>den Gültigkeitsbereich</em> verlässt.</li>
</ul>
<p>An diesem Punkt ist die Beziehung zwischen Gültigkeitsbereichen und wann
Variablen gültig sind ähnlich zu anderen Programmiersprachen. Nun werden wir
auf diesem Verständnis aufbauen, indem wir den Typ <code>String</code> einführen.</p>
<h3><a class="header" href="#der-typ-string" id="der-typ-string">Der Typ <code>String</code></a></h3>
<p>Um die Eigentumsregeln zu veranschaulichen, benötigen wir einen Datentyp, der
komplexer ist als die, die wir im Abschnitt <a href="ch03-02-data-types.html#data-types">&quot;Datentypen&quot;</a> in
Kapitel 3 behandelt haben. Die zuvor behandelten Typen werden alle auf den
Stapelspeicher gelegt und vom Stapelspeicher entfernt, wenn ihr
Gültigkeitsbereich beendet ist, aber wir wollen uns Daten ansehen, die im
dynamischen Speicher gespeichert sind, und untersuchen, woher Rust weiß, wann
es diese Daten aufräumen muss.</p>
<p>Wir werden hier <code>String</code> als Beispiel nehmen und uns auf die Teile von <code>String</code>
konzentrieren, die sich auf die Eigentümerschaft beziehen. Diese Aspekte gelten
auch für andere komplexe Datentypen, unabhängig davon, ob sie von der
Standardbibliothek bereitgestellt oder von dir erstellt wurden. Wir werden
<code>String</code> in Kapitel 8 eingehender behandeln.</p>
<p>Wir haben bereits Zeichenkettenliterale gesehen, bei denen ein
Zeichenkettenwert fest in unserem Programm kodiert ist. Zeichenkettenliterale
sind praktisch, aber sie eignen sich nicht für jede Situation, in der wir Text
verwenden möchten. Ein Grund dafür ist, dass sie unveränderlich sind. Ein
anderer Grund ist, dass nicht jeder Zeichenkettenwert bekannt ist, wenn wir
unseren Code schreiben: Was ist zum Beispiel, wenn wir Benutzereingaben
entgegennehmen und speichern wollen? Für diese Situationen hat Rust einen
zweiten Zeichenkettentyp: <code>String</code>. Dieser Typ wird im dynamischen Speicher
allokiert und kann so eine Textmenge speichern, die uns zur Kompilierzeit
unbekannt ist. Du kannst einen <code>String</code> aus einem Zeichenkettenliteral
erzeugen, indem du die Funktion <code>from</code> wie folgt verwendest:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;Hallo&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Der doppelte Doppelpunkt (<code>::</code>) ist ein Operator, der es uns erlaubt, diese
spezielle Funktion <code>from</code> mit dem Namensraum des <code>String</code>-Typs zu benennen,
anstatt einen Namen wie <code>string_from</code> zu verwenden. Wir werden diese Syntax im
Abschnitt <a href="ch05-03-method-syntax.html#method-syntax">„Methodensyntax“</a> in Kapitel 5 näher betrachten, und
wenn wir in Kapitel 7 unter <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">„Mit Pfaden auf ein Element im Modulbaum
verweisen“</a> über den Namensraum mit Modulen sprechen. </p>
<p>Diese Art von Zeichenkette kann <em>verändert</em> werden:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;Hallo&quot;);

s.push_str(&quot; Welt!&quot;); // push_str() hängt ein Literal an eine Zeichenfolge an

println!(&quot;{}&quot;, s);    // Gibt `Hallo Welt!` aus
<span class="boring">}
</span></code></pre></pre>
<p>Was ist hier nun der Unterschied? Warum kann <code>String</code> verändert werden,
Literale jedoch nicht? Der Unterschied liegt darin, wie diese beiden Typen mit
dem Arbeitsspeicher umgehen.</p>
<h3><a class="header" href="#speicher-und-allokation" id="speicher-und-allokation">Speicher und Allokation</a></h3>
<p>Im Falle eines Zeichenkettenliterals kennen wir den Inhalt zum Zeitpunkt der
Kompilierung, sodass der Text direkt in die endgültige ausführbare Datei fest
kodiert wird. Aus diesem Grund sind Zeichenkettenliterale schnell und
effizient. Allerdings ergeben sich diese Eigenschaften nur aus der
Unveränderlichkeit des Zeichenkettenliterals. Leider können wir nicht für jedes
Stück Text, dessen Größe zum Zeitpunkt der Kompilierung unbekannt ist und
dessen Größe sich während der Ausführung des Programms ändern könnte, einen
Speicherblock in die Binärdatei packen.</p>
<p>Um mit dem Typ <code>String</code> einen veränderlichen, größenänderbaren Textabschnitt zu
unterstützen, müssen wir Speicher im dynamischen Speicher allokieren, dessen
Größe zur Kompilierzeit unbekannt ist. Dies bedeutet:</p>
<ul>
<li>Der Speicher muss zur Laufzeit vom Betriebssystem angefordert werden.</li>
<li>Wir brauchen eine Möglichkeit, diesen Speicher an das Betriebssystem
zurückzugeben, wenn wir mit unserem <code>String</code> fertig sind.</li>
</ul>
<p>Der erste Teil wird von uns erledigt: Wenn wir <code>String::from</code> aufrufen, fordert
seine Implementierung den Speicher an, den sie benötigt. Dies ist in
Programmiersprachen ziemlich einheitlich.</p>
<p>Der zweite Teil ist jedoch anders. In Sprachen mit einer <em>automatischen
Speicherbereinigung</em> (garbage collector, GC) behält der GC den Überblick und
räumt Speicherplatz, der nicht mehr verwendet wird, auf; wir brauchen nicht
darüber nachzudenken. Ohne einen GC liegt es in unserer Verantwortung, zu
erkennen, wann Speicherplatz nicht mehr benutzt wird, und Code aufzurufen, der
ihn explizit zurückgibt, so wie wir es beim Anfordern auch getan haben. Dies
korrekt zu tun, war in der Vergangenheit ein schwieriges Programmierproblem.
Wenn wir es vergessen, verschwenden wir Speicher. Wenn wir es zu früh machen,
haben wir eine ungültige Variable. Wenn wir es zweimal machen, ist das auch ein
Fehler. Wir müssen eine <em>Allokierung</em> mit genau einer <em>Freigabe</em> paaren.</p>
<p>Rust geht einen anderen Weg: Der Speicher wird automatisch zurückgegeben,
sobald die Variable, die ihn besitzt, den Gültigkeitsbereich verlässt. Hier ist
eine Variante unseres Gültigkeitsbereich-Beispiels aus Codeblock 4-1, bei der
ein <code>String</code> anstelle eines Zeichenkettenliterals verwendet wird:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>{
    let s = String::from(&quot;Hallo&quot;); // s ist ab dieser Stelle gültig

    // etwas mit s machen
}                                  // dieser Gültigkeitsbereich ist nun vorbei,
                                   // und s ist nicht mehr gültig
<span class="boring">}
</span></code></pre></pre>
<p>Es gibt eine natürliche Stelle, an der wir den Speicher, den unser <code>String</code>
benötigt, an das Betriebssystem zurückgeben können: Wenn <code>s</code> den
Gültigkeitsbereich verlässt. Wenn eine Variable den Gültigkeitsbereich
verlässt, ruft Rust für uns eine spezielle Funktion auf: Diese Funktion heißt
<code>drop</code> und an dieser Stelle kann der Autor von <code>String</code> Code einfügen, um den
Speicher zurückzugeben. Rust ruft <code>drop</code> automatisch an der schließenden
geschweiften Klammer auf.</p>
<blockquote>
<p>Hinweis: In C++ wird dieses Muster der Freigabe von Ressourcen am Ende der
Lebensdauer eines Elements manchmal als <em>Ressourcenbelegung ist
Initialisierung</em> (resource acquisition is initialization, RAII) bezeichnet.
Die Funktion <code>drop</code> in Rust wird dir vertraut vorkommen, wenn du bereits
RAII-Muster verwendet hast.</p>
</blockquote>
<p>Dieses Muster hat einen tiefgreifenden Einfluss auf die Art und Weise, wie
Rust-Code geschrieben wird. Es mag im Moment einfach erscheinen, aber das
Verhalten von Code kann in komplizierteren Situationen unerwartet sein, wenn
wir wollen, dass mehrere Variablen Daten verwenden, die wir im dynamischen
Speicher allokiert haben. Lass uns jetzt einige dieser Situationen untersuchen.</p>
<h4><a class="header" href="#wege-wie-variablen-und-daten-interagieren-verschieben-move" id="wege-wie-variablen-und-daten-interagieren-verschieben-move">Wege, wie Variablen und Daten interagieren: Verschieben (move)</a></h4>
<p>Mehrere Variablen können in Rust auf unterschiedliche Weise mit denselben Daten
interagieren. Betrachten wir ein Beispiel mit einer ganzen Zahl in Codeblock
4-2.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = x;
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 4-2: Zuweisen des ganzzahligen Wertes der
Variablen <code>x</code> an <code>y</code></span></p>
<p>Wir können wahrscheinlich erahnen, was das bewirkt: „Binde den Wert <code>5</code> an <code>x</code>;
dann erstelle eine Kopie des Wertes in <code>x</code> und binde ihn an <code>y</code>.“ Wir haben
jetzt zwei Variablen <code>x</code> und <code>y</code> und beide sind gleich <code>5</code>. Das ist in der Tat
der Fall, denn ganze Zahlen sind einfache Werte mit einer bekannten, festen
Größe, und diese beiden Werte <code>5</code> werden auf den Stapelspeicher gelegt.</p>
<p>Schauen wir uns nun die <code>String</code>-Variante an:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;Hallo&quot;);
let s2 = s1;
<span class="boring">}
</span></code></pre></pre>
<p>Dieser sieht dem vorherigen Code sehr ähnlich, sodass wir annehmen könnten,
dass die Funktionsweise die gleiche wäre: Das heißt, die zweite Zeile würde
eine Kopie des Wertes in <code>s1</code> erstellen und sie an <code>s2</code> binden. Aber das ist
nicht ganz das, was passiert.</p>
<p>Betrachte Abbildung 4-1, um zu sehen, was mit dem <code>String</code> unter der Haube
geschieht. Ein <code>String</code> besteht aus drei Teilen, die auf der linken Seite
dargestellt sind: Einem Zeiger auf den Speicherbereich, der den Inhalt der
Zeichenkette enthält, die Länge und die Kapazität. Dieser Datenblock wird auf
dem Stapelspeicher gespeichert. Auf der rechten Seite ist der Speicherbereich
im dynamischen Speicher, der den Inhalt enthält.</p>
<img alt="String im Arbeitsspeicher" src="img/trpl04-01.svg" class="center" style="width: 50%;" />
<p><span class="caption">Abbildung 4-1: Speicherdarstellung eines <code>String</code> mit dem
Wert „Hallo“, gebunden an <code>s1</code></span></p>
<p>Die Länge gibt an, wie viel Speicherplatz in Bytes der Inhalt der Zeichenkette
derzeit belegt. Die Kapazität ist die Gesamtmenge des Speichers in Bytes, die
der <code>String</code> vom Betriebssystem erhalten hat. Der Unterschied zwischen Länge
und Kapazität ist von Bedeutung, aber nicht in diesem Zusammenhang, deshalb ist
es im Moment in Ordnung, die Kapazität zu ignorieren.</p>
<p>Wenn wir <code>s1</code> an <code>s2</code> zuweisen, werden die <code>String</code>-Daten kopiert, d.h. wir
kopieren den Zeiger, die Länge und die Kapazität, die sich auf dem
Stapelspeicher befinden. Wir kopieren nicht die Daten im dynamischen Speicher,
auf die sich der Zeiger bezieht. Die Speicherdarstellung sieht also wie in
Abbildung 4-2 aus.</p>
<img alt="s1 und s2 zeigen auf denselben Wert" src="img/trpl04-02.svg" class="center" style="width: 50%;" />
<p><span class="caption">Abbildung 4-2: Speicherdarstellung der Variable <code>s2</code>, die
eine Kopie des Zeigers, der Länge und der Kapazität von <code>s1</code> hat</span></p>
<p>Die Darstellung sieht <em>nicht</em> wie Abbildung 4-3 aus, so wie der Speicher
aussehen würde, wenn Rust stattdessen auch die Daten im dynamischen Speicher
kopieren würde. Würde Rust dies tun, könnte die Operation <code>s2 = s1</code> bei großen
Datenmengen im dynamischen Speicher sehr teuer hinsichtlich der
Laufzeitperformanz werden.</p>
<img alt="s1 und s2 als vollständige Kopien" src="img/trpl04-03.svg" class="center" style="width: 50%;" />
<p><span class="caption">Abbildung 4-3: Eine weitere Möglichkeit für das, was
<code>s2 = s1</code> tun könnte, falls Rust auch die Daten im dynamischen Speicher
kopieren würde</span></p>
<p>Vorhin sagten wir, dass Rust automatisch die Funktion <code>drop</code> aufruft und den
dynamischen Speicher für diese Variable säubert, wenn eine Variable den
Gültigkeitsbereich verlässt. Abbildung 4-2 zeigt jedoch, dass beide Datenzeiger
auf dieselbe Stelle zeigen. Das ist ein Problem: Wenn <code>s2</code> und <code>s1</code> den
Gültigkeitsbereich verlassen, werden beide versuchen, den gleichen Speicher
freizugeben.</p>
<p>Dies wird als <em>doppelter Freigabefehler</em> (double free error) bezeichnet und ist
einer der Speichersicherheitsfehler, die wir zuvor erwähnt haben. Das
zweimalige Freigeben des Speichers kann zu einer Speicherverfälschung führen,
was potenziell zu Sicherheitslücken führen kann.</p>
<p>Um Speichersicherheit zu gewährleisten, gibt es noch ein weiteres Detail, was
Rust in dieser Situation macht. Anstatt zu versuchen, den allokierten Speicher
zu kopieren, sieht Rust <code>s1</code> als nicht mehr gültig an, und deshalb muss Rust
nichts freigeben, wenn <code>s1</code> den Gültigkeitsbereich verlässt. Schau dir an, was
passiert, wenn du versuchst, <code>s1</code> zu benutzen, nachdem <code>s2</code> erstellt wurde; es
wird nicht funktionieren:</p>
<pre><code class="language-rust ignore does_not_compile">let s1 = String::from(&quot;Hallo&quot;);
let s2 = s1;

println!(&quot;{} Welt!&quot;, s1);
</code></pre>
<p>Du erhältst eine Fehlermeldung wie diese, wodurch Rust dich daran hindert, die
ungültige Referenz zu verwenden:</p>
<pre><code class="language-text">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --&gt; src/main.rs:5:28
  |
2 |     let s1 = String::from(&quot;Hallo&quot;);
  |         -- move occurs because `s1` has type `std::string::String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 | 
5 |     println!(&quot;{} Welt!&quot;, s1);
  |                          ^^ value borrowed here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Wenn du beim Arbeiten mit anderen Sprachen schon mal die Begriffe <em>flache
Kopie</em> (shallow copy) und <em>tiefe Kopie</em> (deep copy) gehört hast, hört sich das
Konzept des Kopierens des Zeigers, der Länge und der Kapazität ohne Kopieren
der Daten nach einer flachen Kopie an. Aber weil Rust auch die erste Variable
ungültig macht, wird es nicht als flache Kopie, sondern als <em>Verschieben</em>
(move) bezeichnet. In diesem Beispiel würden wir sagen, dass <code>s1</code> in <code>s2</code>
<em>verschoben</em> wurde. Was tatsächlich geschieht, ist in Abbildung 4-4
dargestellt.</p>
<img alt="s1 moved to s2" src="img/trpl04-04.svg" class="center" style="width: 50%;" />
<p><span class="caption">Abbildung 4-4: Speicherdarstellung, nachdem <code>s1</code> ungültig
gemacht wurde</span></p>
<p>Damit ist unser Problem gelöst! Da nur <code>s2</code> gültig ist, wenn es den
Gültigkeitsbereich verlässt, wird es allein den Speicher freigeben, und wir
sind fertig.</p>
<p>Darüber hinaus gibt es eine Entwurfsentscheidung, die damit impliziert ist:
Rust wird niemals automatisch „tiefe“ Kopien deiner Daten erstellen. Daher kann
man davon ausgehen, dass jedes <em>automatische</em> Kopieren im Hinblick auf die
Laufzeitperformanz kostengünstig ist.</p>
<h4><a class="header" href="#wege-wie-variablen-und-daten-interagieren-klonen-clone" id="wege-wie-variablen-und-daten-interagieren-klonen-clone">Wege, wie Variablen und Daten interagieren: Klonen (clone)</a></h4>
<p>Wenn wir die Daten von <code>String</code> im dynamischen Speicher <em>tief</em> kopieren wollen,
nicht nur die Stapelspeicher-Daten, können wir eine gängige Methode namens
<code>clone</code> verwenden. Wir werden die Methodensyntax in Kapitel 5 besprechen, aber
da Methoden eine gängige Funktionalität vieler Programmiersprachen sind, hast
du sie wahrscheinlich schon einmal gesehen.</p>
<p>Hier ist ein Beispiel für die Methode <code>clone</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;Hallo&quot;);
let s2 = s1.clone();

println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
<span class="boring">}
</span></code></pre></pre>
<p>Das funktioniert sehr gut und erzeugt explizit das in Abbildung 4-3 gezeigte
Verhalten, bei dem die Daten im dynamischen Speicher <em>kopiert</em> werden.</p>
<p>Wenn du einen Aufruf von <code>clone</code> siehst, weißt du, dass irgendein beliebiger
Code ausgeführt wird und dass dieser Code teuer sein könnte. Es ist ein
visueller Indikator dafür, dass etwas anderes vor sich geht.</p>
<h4><a class="header" href="#nur-stapelspeicher-daten-kopieren-copy" id="nur-stapelspeicher-daten-kopieren-copy">Nur Stapelspeicher-Daten: Kopieren (copy)</a></h4>
<p>Es gibt noch einen weiteren Kniff, über den wir noch nicht gesprochen haben.
Folgender Code mit ganzen Zahlen, der teilweise in Codeblock 4-2 gezeigt wurde,
funktioniert und ist gültig:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = x;

println!(&quot;x = {}, y = {}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<p>Aber dieser Code scheint dem zu widersprechen, was wir gerade gelernt haben:
Wir haben keinen Aufruf von <code>clone</code>, aber <code>x</code> ist immer noch gültig und wurde
nicht in <code>y</code> verschoben.</p>
<p>Der Grund dafür ist, dass Typen wie ganze Zahlen, die zur Kompilierzeit eine
bekannte Größe haben, vollständig auf dem Stack gespeichert werden, so dass
Kopien der tatsächlichen Werte schnell erstellt werden können. Das bedeutet,
dass es keinen Grund gibt, warum wir verhindern wollen, dass <code>x</code> gültig ist,
nachdem wir die Variable <code>y</code> erstellt haben. Mit anderen Worten, es gibt hier
keinen Unterschied zwischen tiefen und flachen Kopien, also würde der Aufruf
<code>clone</code> nichts anderes tun als das übliche flache Kopieren, und wir können es
weglassen.</p>
<p>Rust hat eine spezielle Annotation, das Merkmal <code>Copy</code>, die wir an Typen wie
ganze Zahlen hängen können, die auf dem Stapelspeicher gespeichert sind (wir
werden in Kapitel 10 mehr über Merkmale sprechen). Wenn ein Typ das Merkmal
<code>Copy</code> hat, ist eine ältere Variable nach der Zuweisung noch verwendbar. Rust
lässt uns einen Typ nicht mit dem Merkmal <code>Copy</code> annotieren, wenn der Typ oder
einer seiner Teile das Merkmal <code>Drop</code> implementiert. Wenn der Typ eine
Sonderbehandlung braucht, wenn der Wert den Gültigkeitsbereich verlässt und wir
die Annotation <code>Copy</code> zu diesem Typ hinzufügen, erhalten wir einen
Kompilierfehler. Um zu erfahren, wie du die <code>Copy</code>-Annotation zu deinem Typ
hinzufügen kannst, siehe <a href="appendix-03-derivable-traits.html">„Ableitbare Merkmale (traits)“</a> in
Anhang C.</p>
<p>Welche Typen unterstützen also <code>Copy</code>? Du kannst die Dokumentation für einen
gegebenen Typ überprüfen, um sicherzugehen, aber als allgemeine Regel gilt,
dass jede Gruppierung von einfachen skalaren Werten <code>Copy</code> unterstützt, und
nichts, was eine Allokation erfordert oder irgendeine Form von Ressource ist,
<code>Copy</code> erlaubt. Hier sind einige Typen, die <code>Copy</code> unterstützen:</p>
<ul>
<li>Alle ganzzahligen Typen, z.B. <code>u32</code>.</li>
<li>Der boolesche Typ <code>bool</code> mit den Werten <code>true</code> und <code>false</code>.</li>
<li>Alle Fließkomma-Typen, z.B. <code>f64</code>.</li>
<li>Der Zeichentyp <code>char</code>.</li>
<li>Tupel, wenn sie nur Typen enthalten, die auch <code>Copy</code> unterstützen. Zum
Beispiel unterstützt <code>(i32, i32)</code> <code>Copy</code>, nicht aber <code>(i32, String)</code>.</li>
</ul>
<h3><a class="header" href="#eigentümerschaft-und-funktionen" id="eigentümerschaft-und-funktionen">Eigentümerschaft und Funktionen</a></h3>
<p>Die Semantik für die Übergabe eines Wertes an eine Funktion ist ähnlich wie bei
der Zuweisung eines Wertes an eine Variable. Wenn eine Variable an eine
Funktion übergeben wird, wird sie verschoben oder kopiert, genau wie bei der
Zuweisung. Codeblock 4-3 enthält ein Beispiel mit einigen Anmerkungen, aus
denen hervorgeht, wo Variablen in den Gültigkeitsbereich fallen und wo nicht.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s = String::from(&quot;Hallo&quot;);  // s kommt in den Gültigkeitsbereich

    takes_ownership(s);             // Der Wert von s wird in die Funktion verschoben,
                                    // und ist daher hier nicht mehr gültig.

    let x = 5;                      // x kommt in den Gültigkeitsbereich

    makes_copy(x);                  // x würde in die Funktion verschoben werden,
                                    // aber i32 erlaubt Copy, also ist es in Ordnung,
                                    // danach immer noch x zu verwenden,

} // Hier verlässt x den Gültigkeitsbereich, dann s.
  // Aber weil der Wert von s verschoben wurde, passiert nichts Besonderes.

fn takes_ownership(some_string: String) { // some_string kommt in den Gültigkeitsbereich
    println!(&quot;{}&quot;, some_string);
} // Hier verlässt some_string den Gültigkeitsbereich und `drop` wird aufgerufen.
  // Der zugehörige Speicherplatz wird freigegeben.

fn makes_copy(some_integer: i32) { // some_integer kommt in den Gültigkeitsbereich
    println!(&quot;{}&quot;, some_integer);
} // Hier verlässt some_integer den Gültigkeitsbereich. Es passiert nichts Besonderes.
</code></pre></pre>
<p><span class="caption">Codeblock 4-3: Funktionen mit kommentierter
Eigentümerschaft und Gültigkeitsbereich</span></p>
<p>Wenn wir versuchen würden, <code>s</code> nach dem Aufruf von <code>takes_ownership</code> zu
verwenden, würde Rust einen Kompilierfehler anzeigen. Diese statischen
Prüfungen schützen uns vor Fehlern. Versuche, weiteren Code zu <code>main</code>
hinzuzufügen, der <code>s</code> und <code>x</code> verwendet, um zu sehen, wo du sie verwenden
kannst und wo die Eigentumsregeln dich daran hindern.</p>
<h3><a class="header" href="#rückgabewerte-und-gültigkeitsbereich" id="rückgabewerte-und-gültigkeitsbereich">Rückgabewerte und Gültigkeitsbereich</a></h3>
<p>Rückgabewerte können auch Eigentümerschaft übertragen. Codeblock 4-4 ist ein
Beispiel mit ähnlichen Anmerkungen wie die in Codeblock 4-3.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = gives_ownership();         // gives_ownership verschiebt seinen
                                        // Rückgabewert in s1

    let s2 = String::from(&quot;Hallo&quot;);     // s2 kommt in den Gültigkeitsbereich

    let s3 = takes_and_gives_back(s2);  // s2 wird in takes_and_gives_back verschoben
                                        // und der Rückgabewert wird in s3 verschoben

} // Hier verlässt s3 den Gültigkeitsbereich und wird aufgeräumt.
  // s2 verlässt den Gültigkeitsbereich, wurde aber verschoben, es passiert also nichts.
  // s1 verlässt den Gültigkeitsbereich und wird aufgeräumt.

fn gives_ownership() -&gt; String {        // gives_ownership verschiebt seinen
                                        // Rückgabewert in die aufrufende Funktion

    let some_string = String::from(&quot;hello&quot;); // some_string kommt in den
                                             // Gültigkeitsbereich

    some_string                         // some_string wird zurückgegeben und
                                        // wird an die aufrufende Funktion verschoben
}

// takes_and_gives_back nimmt einen String entgegen und gibt einen zurück
fn takes_and_gives_back(a_string: String) -&gt; String { // a_string kommt in den
                                                      // Gültigkeitsbereich

    a_string  // a_string wird zurückgegeben und
              // an die aufrufende Funktion verschoben
}
</code></pre></pre>
<p><span class="caption">Codeblock 4-4: Übertragen der Eigentümerschaft an Rückgabewerten</span></p>
<p>Die Eigentümerschaft an einer Variable folgt jedes Mal dem gleichen Muster: Das
Zuweisen eines Wertes an eine andere Variable verschiebt diese. Wenn eine
Variable, die Daten im dynamischen Speicher enthält, den Gültigkeitsbereich
verlässt, wird der Wert durch <code>drop</code> aufgeräumt, es sei denn, die Daten wurden
in das Eigentum einer anderen Variable verschoben.</p>
<p>Es ist etwas mühsam, das Eigentum zu übernehmen und es dann mit jeder Funktion
zurückzugeben. Was ist, wenn wir eine Funktion einen Wert nutzen lassen wollen,
aber nicht die Eigentümerschaft übergeben wollen? Es ist ziemlich lästig, dass
alles, was wir übergeben, auch wieder zurückgegeben werden muss, wenn wir es
wieder verwenden wollen, zusätzlich zu den Daten, die sich aus dem
Funktionsrumpf ergeben, die wir vielleicht auch zurückgeben wollen.</p>
<p>Es ist möglich, mehrere Werte mit Hilfe eines Tupels zurückzugeben, wie in
Codeblock 4-5 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;Hallo&quot;);

    let (s2, len) = calculate_length(s1);

    println!(&quot;Die Länge von '{}' ist {}.&quot;, s2, len);
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len(); // len() gibt die Länge der Zeichenkette zurück

    (s, length)
}
</code></pre></pre>
<p><span class="caption">Codeblock 4-5: Rückgeben der Eigentümerschaft an
Parametern</span></p>
<p>Aber das ist zu viel Zeremonie und zu viel Arbeit für ein Konzept, das
gebräuchlich sein sollte. Zum Glück hat Rust für uns eine Funktionalität zu
diesem Konzept, das <em>Referenzen</em> (references) genannt wird.</p>
<h2><a class="header" href="#referenzen-und-ausleihen-borrowing" id="referenzen-und-ausleihen-borrowing">Referenzen und Ausleihen (borrowing)</a></h2>
<p>Das Problem mit dem Tupelcode in Codeblock 4-5 ist, dass wir der aufrufenden
Funktion den <code>String</code> zurückgeben müssen, damit wir den <code>String</code> nach dem
Aufruf von <code>calculate_length</code> weiter verwenden können, weil der <code>String</code> in
<code>calculate_length</code> verschoben wurde.</p>
<p>Im Folgenden siehst du, wie du eine Funktion <code>calculate_length</code> definieren und
verwenden kannst, die eine Referenz auf ein Objekt als Parameter hat, anstatt
die Eigentümerschaft (ownership) des Wertes zu übernehmen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;Hallo&quot;);

    let len = calculate_length(&amp;s1);

    println!(&quot;Die Länge von '{}' ist {}.&quot;, s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}
</code></pre></pre>
<p>Beachte, dass der gesamte Tupelcode aus der Variablendeklaration und dem
Rückgabewert der Funktion verschwunden ist. Beachte des Weiteren, dass wir
<code>&amp;s1</code> an <code>calculate_length</code> übergeben und in seiner Definition <code>&amp;String</code> statt
<code>String</code> steht.</p>
<p>Das <code>&amp;</code>-Zeichen steht für eine <em>Referenz</em>, und sie ermöglicht es dir, sich auf
einen Wert zu beziehen, ohne dessen Eigentümerschaft zu übernehmen. Abbildung
4-5 zeigt die Speicherdarstellung.</p>
<img alt="&String s zeigt auf String s1" src="img/trpl04-05.svg" class="center" />
<p><span class="caption">Abbildung 4-5: Eine Grafik mit <code>&amp;String s</code>, das auf
<code>String s1</code> zeigt</span></p>
<blockquote>
<p>Anmerkung: Das Gegenteil der Referenzierung durch <code>&amp;</code> ist die
<em>Dereferenzierung</em> (dereferencing), die mittels Dereferenzoperator <code>*</code>
erfolgt. Wir werden in Kapitel 8 einige Verwendungen des Dereferenzoperators
sehen und in Kapitel 15 Einzelheiten der Dereferenzierung besprechen.</p>
</blockquote>
<p>Schauen wir uns den Funktionsaufruf hier genauer an:</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;Hallo&quot;);

    let len = calculate_length(&amp;s1);
<span class="boring">
</span><span class="boring">    println!(&quot;Die Länge von '{}' ist {}.&quot;, s1, len);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn calculate_length(s: &amp;String) -&gt; usize {
</span><span class="boring">    s.len()
</span><span class="boring">}
</span></code></pre></pre>
<p>Die Syntax <code>&amp;s1</code> erlaubt es uns, eine Referenz zu erstellen, die auf den Wert
von <code>s1</code> <em>referenziert</em>, ihn aber nicht besitzt. Da sie diese nicht besitzt,
verfällt der Wert, auf den sie verweist, nicht, wenn die Referenz den
Gültigkeitsbereich verlässt.</p>
<p>Ebenso verwendet die Signatur der Funktion das Zeichen <code>&amp;</code>, um anzuzeigen, dass
der Typ des Parameters <code>s</code> eine Referenz ist. Lass uns einige erklärende
Anmerkungen ergänzen:</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let s1 = String::from(&quot;Hallo&quot;);
</span><span class="boring">
</span><span class="boring">    let len = calculate_length(&amp;s1);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Die Länge von '{}' ist {}.&quot;, s1, len);
</span><span class="boring">}
</span><span class="boring">
</span>fn calculate_length(s: &amp;String) -&gt; usize { // s ist eine Referenz
                                           // auf eine Zeichenkette
    s.len()
} // Hier verlässt s den Gültigkeitsbereich. Aber weil es keine
  // Eigentümerschaft an dem hat, worauf es referenziert, passiert nichts.
</code></pre></pre>
<p>Der Gültigkeitsbereich, in dem die Variable <code>s</code> gültig ist, ist derselbe wie
der Gültigkeitsbereich aller Funktionsparameter, aber wir lassen nicht
verfallen, worauf die Referenz verweist, wenn sie den Gültigkeitsbereich
verlässt, weil wir keine Eigentümerschaft haben. Wenn Funktionen statt der
tatsächlichen Werte Referenzen als Parameter haben, brauchen wir die Werte
nicht zurückzugeben, um die Eigentümerschaft zurückzugeben, denn wir hatten nie
die Eigentümerschaft.</p>
<p>Referenzen als Funktionsparameter bezeichnen wir als <em>Ausleihen</em> (borrowing).
Wenn eine Person im richtigen Leben etwas besitzt, kannst du es von ihr
ausleihen. Wenn du fertig bist, musst du es zurückgeben.</p>
<p>Was passiert nun, wenn wir versuchen, etwas zu verändern, das wir uns
ausleihen? Versuche den Code in Codeblock 4-6. Achtung: Es funktioniert nicht!</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let s = String::from(&quot;Hallo&quot;);

    change(&amp;s);
}

fn change(some_string: &amp;String) {
    some_string.push_str(&quot; Welt&quot;);
}
</code></pre>
<p><span class="caption">Codeblock 4-6: Versuch, einen ausgeliehenen Wert zu
verändern</span></p>
<p>Hier ist die Fehlermeldung:</p>
<pre><code class="language-text">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference
 --&gt; src/main.rs:8:5
  |
7 | fn change(some_string: &amp;String) {
  |                        ------- help: consider changing this to be a mutable reference: `&amp;mut std::string::String`
8 |     some_string.push_str(&quot; Welt&quot;);
  |     ^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable

error: aborting due to previous error

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
</code></pre>
<p>So wie Variablen standardmäßig unveränderlich sind, so sind auch Referenzen
unveränderlich. Es ist uns nicht erlaubt, etwas zu verändern, auf das wir eine
Referenz haben.</p>
<h3><a class="header" href="#veränderliche-referenzen" id="veränderliche-referenzen">Veränderliche Referenzen</a></h3>
<p>Wir können den Fehler im Code von Codeblock 4-6 mit nur einer kleinen Änderung
beheben:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;Hallo&quot;);

    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(&quot; Welt&quot;);
}
</code></pre></pre>
<p>Zuerst mussten wir <code>s</code> ändern, um <code>mut</code> zu sein. Dann mussten wir eine
veränderliche Referenz mit <code>&amp;mut s</code> erstellen und eine veränderliche Referenz
mit <code>some_string: &amp;mut String</code> entgegennehmen.</p>
<p>Veränderliche Referenzen haben jedoch eine große Einschränkung: Du kannst nur
eine veränderliche Referenz auf einen bestimmten Datenwert in einem bestimmten
Gültigkeitsbereich haben. Dieser Code wird fehlschlagen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">let mut s = String::from(&quot;Hallo&quot;);

let r1 = &amp;mut s;
let r2 = &amp;mut s;

println!(&quot;{}, {}&quot;, r1, r2);
</code></pre>
<p>Hier ist die Fehlermeldung:</p>
<pre><code class="language-text">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; src/main.rs:5:14
  |
4 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 | 
7 |     println!(&quot;{}, {}&quot;, r1, r2);
  |                        -- first borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Diese Beschränkung erlaubt das Verändern von Werten, aber auf eine sehr
kontrollierte Weise. Das ist etwas, womit neue Rust-Entwickler zu kämpfen
haben, denn in den meisten Sprachen kann man verändern, wann immer man will.</p>
<p>Diese Beschränkung hat den Vorteil, dass Rust Daten-Wettlaufsituation zur
Kompilierzeit verhindern kann. Eine <em>Daten-Wettlaufsituation</em> (data race) ist
ähnlich einer Wettlaufsituation (race condition) und tritt auf, wenn diese drei
Verhaltensweisen auftreten:</p>
<ul>
<li>Zwei oder mehr Zeiger greifen gleichzeitig auf dasselbe Datum zu.</li>
<li>Mindestens einer der Zeiger wird zum Schreiben auf das Datum verwendet.</li>
<li>Es kommt kein Mechanismus zur Anwendung, den Zugriff auf die Daten zu
synchronisieren.</li>
</ul>
<p>Daten-Wettlaufsituationen verursachen undefiniertes Verhalten und können
schwierig zu diagnostizieren und zu beheben sein, wenn du versuchst, sie zur
Laufzeit aufzuspüren; Rust verhindert dieses Problem, indem es Code mit
Daten-Wettlaufsituationen gar nicht erst kompiliert!</p>
<p>Wie immer können wir geschweifte Klammern verwenden, um einen neuen
Gültigkeitsbereich zu schaffen, der mehrere veränderliche Verweise erlaubt, nur
nicht <em>gleichzeitige</em>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;Hallo&quot;);

{
    let r1 = &amp;mut s;
} // r1 verlässt hier den Gültigkeitsbereich, sodass wir
  // problemlos eine neue Referenz erstellen können.

let r2 = &amp;mut s;
<span class="boring">}
</span></code></pre></pre>
<p>Eine ähnliche Regel gibt es für die Kombination von veränderlichen und
unveränderlichen Referenzen. Dieser Code führt zu einem Fehler:</p>
<pre><code class="language-rust ignore does_not_compile">let mut s = String::from(&quot;Hallo&quot;);

let r1 = &amp;s;     // kein Problem
let r2 = &amp;s;     // kein Problem
let r3 = &amp;mut s; // GROSSES PROBLEM

println!(&quot;{}, {} und {}&quot;, r1, r2, r3);
</code></pre>
<p>Hier ist die Fehlermeldung:</p>
<pre><code class="language-text">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:14
  |
4 |     let r1 = &amp;s;     // kein Problem
  |              -- immutable borrow occurs here
5 |     let r2 = &amp;s;     // kein Problem
6 |     let r3 = &amp;mut s; // GROSSES PROBLEM
  |              ^^^^^^ mutable borrow occurs here
7 | 
8 |     println!(&quot;{}, {} und {}&quot;, r1, r2, r3);
  |                               -- immutable borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Puh! Wir können auch keine veränderlichen Referenzen haben, solange wir eine
unveränderliche haben. Nutzer einer unveränderlichen Referenz erwarten nicht,
dass sich die Werte dahinter plötzlich ändern! Mehrere unveränderliche
Referenzen sind jedoch in Ordnung, da niemand, der die Daten nur liest, die
Möglichkeit hat, das Lesen der Daten durch andere zu beeinflussen.</p>
<p>Beachte, dass der Gültigkeitsbereich einer Referenz dort beginnt, wo sie
eingeführt wird, und sich bis zur letzten Verwendung dieser Referenz fortsetzt. 
Zum Beispiel kompiliert dieser Code, weil die letzte Verwendung der
unveränderlichen Referenzen vor der Einführung der veränderlichen Referenz
erfolgt:</p>
<pre><pre class="playpen"><code class="language-rust edition2018">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;Hallo&quot;);

let r1 = &amp;s; // kein Problem
let r2 = &amp;s; // kein Problem
println!(&quot;{} und {}&quot;, r1, r2);
// r1 und r2 werden nach dieser Stelle nicht mehr verwendet

let r3 = &amp;mut s; // kein Problem
println!(&quot;{}&quot;, r3);
<span class="boring">}
</span></code></pre></pre>
<p>Die Gültigkeitsbereiche der unveränderlichen Referenzen <code>r1</code> und <code>r2</code> enden
nach dem <code>println!</code>, wo sie zuletzt verwendet werden, d.h. bevor die
veränderliche Referenz <code>r3</code> erstellt wird. Diese Gültigkeitsbereiche
überschneiden sich nicht, daher ist dieser Code zulässig.</p>
<p>Auch wenn das Ausleihen von Fehlern manchmal frustrierend sein kann, denke
daran, dass es der Rust-Kompilierer ist, der frühzeitig (zur Kompilierzeit und
nicht zur Laufzeit) auf einen möglichen Fehler hinweist und dir genau zeigt, wo
das Problem liegt. Dann musst du nicht aufspüren, warum deine Daten nicht so
sind, wie du dachtest.</p>
<h3><a class="header" href="#hängende-referenzen" id="hängende-referenzen">Hängende Referenzen</a></h3>
<p>In Sprachen mit Zeigern ist es leicht, fälschlicherweise einen <em>hängenden
Zeiger</em> (dangling pointer) zu erzeugen, also einen Zeiger, der auf eine Stelle
im Speicher verweist, die vielleicht an jemand anderem vergeben wurde, weil der
Speicher freigegeben wurde, während noch ein Zeiger auf diesen Speicher
bestehen bleibt. In Rust hingegen garantiert der Kompilierer, dass Referenzen
niemals hängende Referenzen sein können: Wenn du eine Referenz auf Daten hast,
stellt der Kompilierer sicher, dass die Daten nicht den Gültigkeitsbereich
verlassen, bevor die Referenz auf die Daten dies tut.</p>
<p>Versuchen wir, eine hängende Referenz zu erstellen, was Rust mit einem
Kompilierfehler verhindern wird:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from(&quot;Hallo&quot;);

    &amp;s
}
</code></pre>
<p>Hier ist die Fehlermeldung:</p>
<pre><code class="language-text">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:5:16
  |
5 | fn dangle() -&gt; &amp;String {
  |                ^ help: consider giving it a 'static lifetime: `&amp;'static`
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from

error: aborting due to previous error

For more information about this error, try `rustc --explain E0106`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Diese Fehlermeldung bezieht sich auf eine Funktionalität, die wir noch nicht
behandelt haben: Die Lebensdauer. Wir werden die Lebensdauer in Kapitel 10 im
Detail besprechen. Abgesehen von den Hinweisen zur Lebensdauer enthält die
Meldung den entscheidenden Hinweis, warum dieser Code nicht funktioniert:</p>
<blockquote>
<p>Hilfe: Der Rückgabetyp dieser Funktion enthält einen ausgeliehenen Wert, aber
es gibt keinen Wert der ausgeliehen werden kann.</p>
</blockquote>
<p>Lass uns einen genaueren Blick auf das werfen, was in jeder Phase unseres
<code>dangle</code>-Codes geschieht:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let reference_to_nothing = dangle();
</span><span class="boring">}
</span><span class="boring">
</span>fn dangle() -&gt; &amp;String { // dangle gibt eine Referenz
                         // auf eine Zeichenkette zurück

    let s = String::from(&quot;Hallo&quot;); // s ist eine neue Zeichenkette

    &amp;s // wir geben einen Verweis auf die Zeichenkette s zurück
} // Hier verlässt s den Gültigkeitsbereich und wird verworfen.
  // Sein Speicherplatz wird aufgeräumt. Gefahr!
</code></pre>
<p>Da <code>s</code> innerhalb <code>dangle</code> erzeugt wird, wird <code>s</code> wieder freigegeben, wenn der
Code von <code>dangle</code> zu Ende ist. Aber wir haben versucht, eine Referenz darauf
zurückzugeben. Das heißt, diese Referenz würde auf einen ungültigen <code>String</code>
verweisen. Das ist nicht gut! Rust lässt uns das nicht tun.</p>
<p>Die Lösung ist, den <code>String</code> direkt zurückzugeben:</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string = no_dangle();
</span><span class="boring">}
</span><span class="boring">
</span>fn no_dangle() -&gt; String {
    let s = String::from(&quot;Hello&quot;);

    s
}
</code></pre></pre>
<p>Dies funktioniert ohne Probleme. Die Eigentümerschaft wird nach außen
verschoben, und nichts wird freigegeben.</p>
<h3><a class="header" href="#regeln-für-referenzen" id="regeln-für-referenzen">Regeln für Referenzen</a></h3>
<p>Lass uns rekapitulieren, was wir über Referenzen gelernt haben:</p>
<ul>
<li>Zu jedem beliebigen Zeitpunkt kannst du <em>entweder</em> eine veränderliche
Referenz <em>oder</em> eine beliebige Anzahl unveränderlicher Referenzen haben.</li>
<li>Referenzen müssen immer gültig sein.</li>
</ul>
<p>Als Nächstes werden wir uns mit einer anderen Art von Referenz befassen:
Anteilstypen (slice).</p>
<h2><a class="header" href="#der-anteilstyp-slice" id="der-anteilstyp-slice">Der Anteilstyp (slice)</a></h2>
<p>Ein weiterer Datentyp, für den keine Eigentümerschaft besteht, ist der
<em>Anteilstyp</em> (slice). Mit Anteilstypen kannst du auf eine zusammenhängende
Folge von Elementen in einer Kollektion verweisen, anstatt auf die gesamte
Kollektion.</p>
<p>Hier ist ein kleines Programmierproblem: Schreibe eine Funktion, die eine
Zeichenkette entgegennimmt und das erste Wort zurückgibt, das sie in dieser
Zeichenkette findet. Wenn die Funktion kein Leerzeichen in der Zeichenkette
findet, muss die gesamte Zeichenkette ein Wort sein, also sollte die gesamte
Zeichenkette zurückgegeben werden.</p>
<p>Lass uns über die Signatur dieser Funktion nachdenken:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; ?
</code></pre>
<p>Diese Funktion <code>first_word</code> hat einen <code>&amp;String</code> als Parameter. Wir wollen keine
Eigentümerschaft, also ist das in Ordnung. Aber was sollen wir zurückgeben? Wir
haben nicht wirklich eine Möglichkeit, über <em>einen Teil</em> einer Zeichenkette zu
sprechen. Wir könnten jedoch den Index des Wortendes zurückgeben. Versuchen wir
das, wie in Codeblock 4-7 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn first_word(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 4-7: Die Funktion <code>first_word</code>, die einen
Byte-Indexwert zum Parameter <code>String</code> zurückgibt</span></p>
<p>Da wir den <code>String</code> Zeichen für Zeichen durchgehen und prüfen müssen, ob ein
Wert ein Leerzeichen ist, wandeln wir unseren <code>String</code> mit der Methode
<code>as_bytes</code> in ein Byte-Array um:</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span>    let bytes = s.as_bytes();
<span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>Als nächstes erstellen wir einen Iterator über das Byte-Array, indem wir die
Methode <code>iter</code> verwenden:</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span>    for (i, &amp;item) in bytes.iter().enumerate() {
<span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>Auf Iteratoren werden wir in Kapitel 13 näher eingehen. Fürs Erste solltest du
wissen, dass <code>iter</code> eine Methode ist, die jedes Element in einer Kollektion
zurückgibt und dass <code>enumerate</code> das Ergebnis von <code>iter</code> umhüllt und stattdessen
jedes Element als Teil eines Tupels zurückgibt. Das erste Element des Tupels,
das von <code>enumerate</code> zurückgegeben wird, ist der Index, und das zweite Element
ist eine Referenz auf das Element. Das ist etwas bequemer, als den Index selbst
zu berechnen.</p>
<p>Da die Methode <code>enumerate</code> ein Tupel zurückgibt, können wir Muster verwenden,
um dieses Tupel zu zerlegen, so wie überall in Rust. In der <code>for</code>-Schleife
spezifizieren wir also ein Muster, das <code>i</code> für den Index im Tupel und <code>&amp;item</code>
für das einzelne Byte im Tupel hat. Da wir eine Referenz auf das Element aus
<code>.iter().enumerate()</code> erhalten, verwenden wir <code>&amp;</code> im Muster.</p>
<p>Innerhalb der <code>for</code>-Schleife suchen wir mit Hilfe der Byte-Literal-Syntax
<code>b' '</code> nach dem Byte, das das Leerzeichen repräsentiert. Wenn wir ein
Leerzeichen finden, geben wir die Position zurück. Andernfalls geben wir die
Länge der Zeichenkette zurück, indem wir <code>s.len()</code> verwenden:</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span>        if item == b' ' {
            return i;
        }
    }

    s.len()
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>Wir haben jetzt eine Möglichkeit, den Index des ersten Wortendes in der
Zeichenkette herauszufinden, aber es gibt ein Problem. Wir geben ein <code>usize</code>
für sich allein zurück, aber die Zahl ist nur aussagekräftig im Kontext des
<code>&amp;String</code>. Mit anderen Worten: Da es sich um einen vom <code>String</code> getrennten Wert
handelt, gibt es keine Garantie, dass er auch in Zukunft noch gültig ist.
Betrachte das Programm in Codeblock 4-8, das die Funktion <code>first_word</code> aus
Codeblock 4-7 verwendet.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;Hallo Welt&quot;);

    let word = first_word(&amp;s); // word erhält den Wert 5

    s.clear(); // leert die Zeichenkette und macht sie gleich &quot;&quot;

    // word hat noch immer den Wert 5, aber es gibt keine Zeichenkette mehr,
    // mit der wir den Wert 5 sinnvoll verwenden könnten.
    // word ist jetzt völlig ungültig!
}
</code></pre></pre>
<p><span class="caption">Codeblock 4-8: Speichern des Ergebnisses des
Funktionsaufrufs <code>first_word</code> und anschließendes Ändern des Inhalts der
Zeichenkette</span></p>
<p>Dieses Programm kompiliert fehlerfrei und würde dies auch tun, wenn wir <code>word</code>
nach dem Aufruf von <code>s.clear()</code> benutzen würden. Da <code>word</code> überhaupt nicht mit
dem Zustand von <code>s</code> verbunden ist, enthält <code>word</code> immer noch den Wert <code>5</code>. Wir
könnten den Wert <code>5</code> mit der Variable <code>s</code> verwenden, um zu versuchen, das erste
Wort zu extrahieren, aber das wäre ein Fehler, weil sich der Inhalt von <code>s</code>
geändert hat, nachdem wir <code>5</code> in <code>word</code> gespeichert haben.</p>
<p>Sich darum kümmern zu müssen, dass der Index in <code>word</code> mit den Daten in <code>s</code>
konform ist, ist mühsam und fehleranfällig! Das Verwalten dieser Indizes ist
noch fehleranfälliger, wenn wir eine Funktion <code>second_word</code> schreiben. Ihre
Signatur müsste dann so aussehen:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; (usize, usize) {
</code></pre>
<p>Jetzt verfolgen wir einen Anfangs- <em>und</em> einen Endindex, und wir haben noch
mehr Werte, die aus Daten in einem bestimmten Zustand berechnet wurden, aber
überhaupt nicht an diesen Zustand gebunden sind. Wir haben jetzt drei
unverbundene Variablen, die synchron gehalten werden müssen.</p>
<p>Glücklicherweise hat Rust eine Lösung für dieses Problem:
Zeichenkettenanteilstypen</p>
<h3><a class="header" href="#zeichenkettenanteilstypen-string-slices" id="zeichenkettenanteilstypen-string-slices">Zeichenkettenanteilstypen (string slices)</a></h3>
<p>Ein <em>Zeichenkettenanteilstyp</em>  (string slice) ist ein Verweis auf einen Teil
eines <code>String</code>, und er sieht so aus:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;Hallo Welt&quot;);

let hello = &amp;s[0..5];
let world = &amp;s[6..10];
<span class="boring">}
</span></code></pre></pre>
<p>Dies ist ähnlich zu einem Verweis auf den gesamten <code>String</code>, aber mit
zusätzlichem <code>[0..5]</code>. Es handelt sich nicht um eine Referenz auf den gesamten
<code>String</code>, sondern auf einen Teil des <code>String</code>.</p>
<p>Wir können Anteilstypen mit einem Bereich innerhalb Klammern erstellen, indem
wir <code>[starting_index..ending_index]</code> angeben, wobei <code>starting_index</code> die erste
Position im Anteilstyp ist und <code>ending_index</code> die Position hinter der letzten
Position im Anteilstyp. Intern speichert die Anteilstyp-Datenstruktur die
Startposition und die Länge des Anteilstyps, was <code>ending_index</code> minus
<code>starting_index</code> entspricht. Im Fall von <code>let world = &amp;s[6..10];</code> wäre <code>world</code>
also ein Anteilstyp, der einen Zeiger auf das 7. Byte (von 1 an gezählt) von
<code>s</code> mit einem Längenwert von 4 enthält.</p>
<p>Abbildung 4-6 zeigt dies.</p>
<p><img alt="world mit einem Zeiger auf das 6. Byte von String s und einer Länge von 4"
src="img/trpl04-06.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Abbildung 4-6: Zeichenkettenanteilstyp, der sich auf einen
Teil eines <code>String</code> bezieht</span></p>
<p>Wenn du mit der Bereichssyntax <code>..</code> in Rust beim ersten Index (Null) beginnen
willst, kannst du den Wert vor den zwei Punkte weglassen. Mit anderen Worten
sind diese gleich:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;Hallo&quot;);

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
<span class="boring">}
</span></code></pre></pre>
<p>Ebenso kannst du den Endindex weglassen, wenn dein Anteilstyp das letzte Byte
des <code>String</code> enthält. Das bedeutet, dass diese gleich sind:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;Hallo&quot;);

let len = s.len();

let slice = &amp;s[3..len];
let slice = &amp;s[3..];
<span class="boring">}
</span></code></pre></pre>
<p>Du kannst auch beide Werte weglassen, um einen Ausschnitt der gesamten
Zeichenkette zu beschreiben. Diese sind also gleichwertig:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;Hallo&quot;);

let len = s.len();

let slice = &amp;s[0..len];
let slice = &amp;s[..];
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Hinweis: Bereichsindizes bei Zeichenkettenanteilstypen müssen sich nach
gültigen UTF-8-Zeichengrenzen richten. Wenn du versuchst, einen
Zeichenkettenanteilstyp in der Mitte eines Mehrbyte-Zeichens zu erstellen,
wird dein Programm mit einem Fehler abbrechen. Bei der Einführung von
Zeichenkettenanteilstypen in diesem Abschnitt gehen wir nur von ASCII aus;
eine eingehendere Diskussion der UTF-8-Behandlung findet sich im Abschnitt
<a href="ch08-02-strings.html#storing-utf-8-encoded-text-with-strings">„Speichern von UTF-8-kodiertem Text mit Zeichenketten“</a> in Kapitel
8.</p>
</blockquote>
<p>Mit all diesen Informationen im Hinterkopf schreiben wir <code>first_word</code> so um,
dass es einen Anteilstyp zurückgibt. Der Typ mit der Bedeutung
„Zeichenkettenanteilstyp“ wird <code>&amp;str</code> geschrieben:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Den Index für das Wortende erhalten wir auf die gleiche Weise wie in Codeblock
4-7, indem wir nach dem ersten Vorkommen eines Leerzeichens suchen. Wenn wir
ein Leerzeichen finden, geben wir einen Zeichenkettenanteilstyp zurück, wobei
wir den Anfang der Zeichenkette und den Index des Leerzeichens als Anfangs-
bzw. Endindex verwenden.</p>
<p>Wenn wir nun <code>first_word</code> aufrufen, erhalten wir einen einzelnen Wert zurück,
der an die zugrundeliegenden Daten gebunden ist. Der Wert setzt sich aus einer
Referenz auf den Startpunkt des Anteilstyps und der Anzahl der Elemente im
Anteilstyp zusammen.</p>
<p>Die Rückgabe eines Anteilstyps würde auch für eine Funktion <code>second_word</code>
funktionieren:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>Wir haben jetzt eine einfache API, die viel schwieriger durcheinanderzubringen
ist, weil der Kompilierer sicherstellt, dass die Referenzen auf den <code>String</code>
gültig bleiben. Erinnere dich an den Fehler im Programm in Codeblock 4-8, als
wir den Index bis zum Ende des ersten Wortes erhielten, dann aber die
Zeichenkette löschten, sodass unser Index ungültig wurde. Dieser Code war
logisch falsch, zeigte aber keine unmittelbaren Fehler. Die Probleme würden
sich später zeigen, wenn wir weiterhin versuchen würden, den ersten Wortindex
mit einer leeren Zeichenkette zu verwenden. Anteilstypen machen diesen Fehler
unmöglich und lassen uns viel früher wissen, dass wir ein Problem mit unserem
Code haben. Die Anteilstypen-Variante von <code>first_word</code> führt zu einem
Kompilierfehler:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn first_word(s: &amp;String) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;Hallo Welt&quot;);

    let word = first_word(&amp;s);

    s.clear(); // Fehler!

    println!(&quot;Das erste Wort ist: {}&quot;, word);
}
</code></pre>
<p>Hier ist der Kompilierfehler:</p>
<pre><code class="language-text">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --&gt; src/main.rs:18:5
   |
16 |     let word = first_word(&amp;s);
   |                           -- immutable borrow occurs here
17 | 
18 |     s.clear(); // Fehler!
   |     ^^^^^^^^^ mutable borrow occurs here
19 | 
20 |     println!(&quot;Das erste Wort ist: {}&quot;, word);
   |                                        ---- immutable borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Erinnere dich an die Ausleihregeln, durch die wir, wenn wir eine
unveränderliche Referenz auf etwas haben, nicht noch eine veränderliche
Referenz anlegen können. Da <code>clear</code> den <code>String</code> abschneiden muss, muss es
eine veränderliche Referenz erhalten. Rust erlaubt dies nicht und die
Kompilierung schlägt fehl. Rust hat nicht nur die Benutzung unserer API
vereinfacht, sondern auch eine ganze Klasse von Fehlern zur Kompilierzeit
beseitigt!</p>
<h4><a class="header" href="#zeichenkettenliterale-sind-anteilstypen" id="zeichenkettenliterale-sind-anteilstypen">Zeichenkettenliterale sind Anteilstypen</a></h4>
<p>Erinnere dich, dass wir darüber sprachen, dass Zeichenkettenliterale in der
Binärdatei gespeichert werden. Jetzt, da wir über Anteilstypen Bescheid wissen,
können wir Zeichenkettenliterale richtig verstehen:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s = &quot;Hallo Welt!&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>Der Typ von <code>s</code> hier ist <code>&amp;str</code>: Es ist ein Anteilstyp, der auf diesen
speziellen Punkt der Binärdatei zeigt. Das ist auch der Grund, warum
Zeichenkettenliterale unveränderlich sind; <code>&amp;str</code> ist ein unveränderliche
Referenz.</p>
<h4><a class="header" href="#zeichenkettenanteilstypen-als-parameter" id="zeichenkettenanteilstypen-als-parameter">Zeichenkettenanteilstypen als Parameter</a></h4>
<p>Das Wissen, dass man Anteilstypen von Literalen und <code>String</code>-Werten erstellen
kann, führt uns zu einer weiteren Verbesserung von <code>first_word</code>, und das ist
ihre Signatur:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>Ein erfahrenerer Rust-Entwickler würde stattdessen die in Codeblock 4-9
gezeigte Signatur schreiben, da sie es uns erlaubt, dieselbe Funktion sowohl
auf <code>&amp;String</code>-Werte als auch auf <code>&amp;str</code>-Werte anzuwenden.</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
<span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from(&quot;hello world&quot;);
</span><span class="boring">
</span><span class="boring">    // first_word works on slices of `String`s
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = &quot;hello world&quot;;
</span><span class="boring">
</span><span class="boring">    // first_word works on slices of string literals
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // Because string literals *are* string slices already,
</span><span class="boring">    // this works too, without the slice syntax!
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Codeblock 4-9: Verbessern der Funktion <code>first_word</code> durch
Verwenden eines Zeichenkettenanteilstyps für den Typ des Parameters <code>s</code></span></p>
<p>Wenn wir einen Zeichenkettenanteilstyp haben, können wir diesen direkt
übergeben. Wenn wir einen <code>String</code> haben, können wir einen Anteilstyp des
gesamten <code>String</code> übergeben. Das Definieren einer Funktion, die einen
Zeichenkettenanteilstyp statt einer Referenz auf einen <code>String</code> entgegennimmt,
macht unsere API allgemeiner und nützlicher, ohne an Funktionalität einzubüßen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn first_word(s: &amp;str) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let my_string = String::from(&quot;Hallo Welt&quot;);

    // first_word funktioniert mit Anteilstypen von `String`
    let word = first_word(&amp;my_string[..]);

    let my_string_literal = &quot;Hallo Welt&quot;;

    // first_word funktioniert mit Anteilstypen von Zeichenkettenliteralen
    let word = first_word(&amp;my_string_literal[..]);

    // Da Zeichenkettenliterale bereits Zeichenkettenanteilstypen sind,
    // funktioniert dies auch ohne die Anteilstypensyntax!
    let word = first_word(my_string_literal);
}
</code></pre></pre>
<h3><a class="header" href="#andere-anteilstypen" id="andere-anteilstypen">Andere Anteilstypen</a></h3>
<p>Zeichenkettenanteilstypen sind, wie du dir vorstellen kannst, spezifisch für
Zeichenketten. Es gibt aber auch einen allgemeineren Anteilstyp. Betrachte
dieses Array:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<p>Genauso wie wir vielleicht auf einen Teil einer Zeichenkette verweisen möchten,
möchten wir vielleicht auf einen Teil eines Arrays verweisen. Wir würden das so
machen:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];
<span class="boring">}
</span></code></pre></pre>
<p>Dieser Anteilstyp hat den Typ <code>&amp;[i32]</code>. Es funktioniert auf die gleiche Weise
wie bei Zeichenkettenanteilstypen, indem es eine Referenz auf das erste Element
und eine Länge speichert. Du wirst diese Art von Anteilstyp für alle möglichen
anderen Kollektionen verwenden. Wir werden diese Kollektionen im Detail
besprechen, wenn wir in Kapitel 8 über Vektoren sprechen.</p>
<h2><a class="header" href="#zusammenfassung" id="zusammenfassung">Zusammenfassung</a></h2>
<p>Die Konzepte von Eigentümerschaft, Ausleihen und Anteilstypen gewährleisten
Speichersicherheit zur Kompilierzeit in Rust-Programmen. Die Sprache Rust gibt
dir Kontrolle über die Speicherverwendung auf die gleiche Weise wie andere
Systemprogrammiersprachen, aber dadurch dass der Eigentümer der Daten diese
automatisch aufräumt, wenn der Eigentümer den Gültigkeitsbereich verlässt,
bedeutet dies, dass du keinen zusätzlichen Code schreiben und debuggen musst,
um diese Kontrolle zu erhalten.</p>
<p>Die Eigentümerschaft wirkt sich auf die Funktionsweise vieler anderer Teile von
Rust aus, deshalb werden wir im weiteren Verlauf des Buchs weiter über diese
Konzepte sprechen. Lass uns zu Kapitel 5 übergehen und uns das Gruppieren von
Datenteilen zu einer <code>struct</code> ansehen.</p>
<h1><a class="header" href="#strukturen-structs-für-zusammenhängende-daten-verwenden" id="strukturen-structs-für-zusammenhängende-daten-verwenden">Strukturen (structs) für zusammenhängende Daten verwenden</a></h1>
<p>Eine <em>Struktur</em> (struct) ist ein benutzerdefinierter Datentyp, mit dem man
mehrere zusammenhängende Werte, die eine sinnvolle Gruppe bilden,
zusammenpacken und benennen kann. Wenn du mit einer objektorientierten Sprache
vertraut bist, ist eine <em>Struktur</em> analog zu den Datenattributen eines Objekts.
In diesem Kapitel vergleichen wir Tupel mit Strukturen, stellen die
Unterschiede dar, zeigen die Verwendung von Strukturen und erörtern, wie
Methoden und zugehörige Funktionen definiert werden, um das mit den Daten einer
Struktur verbundene Verhalten zu spezifizieren. Strukturen und Aufzählungen
(enums) (siehe Kapitel 6) sind die Bausteine zum Erstellen neuer Typen in der
Domäne deines Programms, mit denen du die Vorteile der Kompilierzeit-Typprüfung
von Rust voll auszuschöpfen kannst.</p>
<h2><a class="header" href="#strukturen-structs-definieren-und-instanziieren" id="strukturen-structs-definieren-und-instanziieren">Strukturen (structs) definieren und instanziieren</a></h2>
<p>Strukturen (structs) ähneln Tupeln, die in Kapitel 3 besprochen wurden. Wie
bei Tupeln können die Teile einer Struktur verschiedene Typen haben. Anders als
bei Tupeln benennst du jedes Teil, damit ist klar, was die Werte bedeuten.
Durch diese Namen sind Strukturen flexibler als Tupel: Du musst dich nicht auf
die Reihenfolge der Daten verlassen, um die Werte einer Instanz zu
spezifizieren oder auf sie zuzugreifen.</p>
<p>Um eine Struktur zu definieren, geben wir das Schlüsselwort <code>struct</code> an und
benennen die gesamte Struktur. Der Name einer Struktur sollte die Bedeutung der
Daten beschreiben, die gruppiert werden. Dann definieren wir innerhalb
geschweifter Klammern die Namen und Typen der Datenteile, die wir <em>Felder</em>
nennen. Beispielsweise zeigt Codeblock 5-1 eine Struktur, die Informationen
über ein Benutzerkonto speichert.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 5-1: Definition der Struktur <code>User</code></span></p>
<p>Um eine Struktur zu verwenden, nachdem wir sie definiert haben, erstellen wir
eine <em>Instanz</em> dieser Struktur, indem wir für jedes Feld einen konkreten Wert
angeben. Wir erzeugen eine Instanz, indem wir den Namen der Struktur angeben
und dann in geschweiften Klammern die <code>Schlüssel: Wert</code>-Paare angeben, wobei
die Schlüssel die Namen der Felder und die Werte die Daten sind, die wir in
diesen Feldern speichern wollen. Wir müssen die Felder nicht in der gleichen
Reihenfolge angeben, in der wir sie in der Struktur deklariert haben. Anders
gesagt ist die Strukturdefinition wie eine allgemeine Typvorlage und Instanzen
füllen diese Vorlage mit bestimmten Daten aus, um Werte des Typs zu erzeugen.
Beispielsweise können wir einen bestimmten Benutzer deklarieren, wie in
Codeblock 5-2 zu sehen ist.</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let user1 = User {
        email: String::from(&quot;jemand@example.com&quot;),
        username: String::from(&quot;benutzername123&quot;),
        active: true,
        sign_in_count: 1,
    };
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 5-2: Eine Instanz der Struktur <code>User</code>
erzeugen</span></p>
<p>Um auf einen bestimmten Wert in einer Struktur zuzugreifen, können wir die
Punktnotation verwenden. Wenn wir nur die E-Mail-Adresse dieses Benutzers
wollen, können wir <code>user1.email</code> überall dort einsetzen, wo wir diesen Wert
verwenden wollen. Wenn die Instanz veränderlich ist, können wir einen Wert
mittels Punktnotation verändern. Codeblock 5-3 gezeigt, wie der Wert im
Feld <code>email</code> einer veränderlichen <code>User</code>-Instanz geändert werden kann.</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let mut user1 = User {
        email: String::from(&quot;jemand@example.com&quot;),
        username: String::from(&quot;benutzername123&quot;),
        active: true,
        sign_in_count: 1,
    };

    user1.email = String::from(&quot;andere-email@example.com&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 5-3: Wert im Feld <code>email</code> einer <code>User</code>-Instanz ändern</span></p>
<p>Beachte, dass die gesamte Instanz veränderlich sein muss. Rust erlaubt es
nicht, nur einzelne Felder als veränderlich zu markieren. Wie mit jedem
Ausdruck können wir eine neue Instanz der Struktur als letzten Ausdruck im
Funktionsrumpf erzeugen, um diese neue Instanz implizit zurückzugeben.</p>
<p>Codeblock 5-4 zeigt eine Funktion <code>build_user</code>, die eine <code>User</code>-Instanz mit der
angegebenen E-Mail und dem Benutzernamen zurückgibt. Das Feld <code>active</code> erhält
den Wert <code>true</code> und das Feld <code>sign_in_count</code> den Wert <code>1</code>.</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from(&quot;jemand@example.com&quot;),
</span><span class="boring">        String::from(&quot;benutzername123&quot;),
</span><span class="boring">    );
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 5-4: Funktion <code>build_user</code>, die eine E-Mail und
einen Benutzernamen entgegennimmt und eine <code>User</code>-Instanz zurückgibt</span></p>
<p>Es ist sinnvoll, den Funktionsparametern dieselben Namen wie die der
Strukturfelder zu geben, jedoch ist das Wiederholen der Feldnamen <code>email</code> und
<code>username</code> etwas mühsam. Wenn die Struktur mehr Felder hätte, würde das
Wiederholen jedes Namens noch lästiger werden. Glücklicherweise gibt es eine
praktische Kurznotation!</p>
<h3><a class="header" href="#kurznotation-der-feld-initialisierung-verwenden-wenn-variablen-und-felder-den-gleichen-namen-haben" id="kurznotation-der-feld-initialisierung-verwenden-wenn-variablen-und-felder-den-gleichen-namen-haben">Kurznotation der Feld-Initialisierung verwenden, wenn Variablen und Felder den gleichen Namen haben</a></h3>
<p>Da die Parameter und die Strukturfelder in Codeblock 5-4 die gleichen Namen
haben, können wir die <em>Kurznotation der Feld-Initialisierung</em> (field init
shorthand syntax) verwenden, um die Funktion <code>build_user</code> so umzuschreiben,
dass sie sich unverändert gleich verhält, ohne <code>email</code> und <code>username</code> zu
wiederholen, siehe Codeblock 5-5.</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from(&quot;jemand@example.com&quot;),
</span><span class="boring">        String::from(&quot;benutzername123&quot;),
</span><span class="boring">    );
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 5-5: Funktion <code>build_user</code> mit Kurznotation der
Feld-Initialisierung, weil die Parameternamen <code>email</code> und <code>username</code> identisch
mit den Strukturfeldern sind</span></p>
<p>Hier erzeugen wir eine neue Instanz der Struktur <code>User</code>, die ein Feld namens
<code>email</code> hat. Wir wollen den Wert des Feldes <code>email</code> auf den Wert des Parameters
<code>email</code> der Funktion <code>build_user</code> setzen. Da das Feld <code>email</code> und der Parameter
<code>email</code> den gleichen Namen haben, brauchen wir nur <code>email</code> statt <code>email: email</code>
zu schreiben.</p>
<h3><a class="header" href="#instanzen-aus-anderen-instanzen-erzeugen-mit-der-strukturaktualisierungssyntax" id="instanzen-aus-anderen-instanzen-erzeugen-mit-der-strukturaktualisierungssyntax">Instanzen aus anderen Instanzen erzeugen mit der Strukturaktualisierungssyntax</a></h3>
<p>Oft ist es hilfreich, eine neue Instanz einer Struktur zu erstellen, die die
meisten Werte einer alten Instanz verwendet und nur einige davon verändert. Du
kannst dazu die <em>Strukturaktualisierungssyntax</em> (struct update syntax)
verwenden.</p>
<p>Zunächst zeigt Codeblock 5-6, wie wir eine neue <code>User</code>-Instanz <code>user2</code> ohne
Aktualisierungssyntax erstellen. Wir setzen neue Werte für <code>email</code> und
<code>username</code>, verwenden aber ansonsten die gleichen Werte von <code>user1</code>, die wir in
Codeblock 5-2 erstellt haben.</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from(&quot;jemand@example.com&quot;),
</span><span class="boring">        username: String::from(&quot;benutzername123&quot;),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span><span class="boring">
</span>    let user2 = User {
        email: String::from(&quot;andere@example.com&quot;),
        username: String::from(&quot;andererbenutzername567&quot;),
        active: user1.active,
        sign_in_count: user1.sign_in_count,
    };
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 5-6: Erstellen einer neuen <code>User</code>-Instanz unter
Verwendung einiger der Werte von <code>user1</code>.</span></p>
<p>Durch Verwenden der Strukturaktualisierungssyntax können wir dasselbe Ergebnis
mit weniger Code erreichen, wie Codeblock 5-7 zeigt. Die Syntax <code>..</code> gibt an,
dass die restlichen Felder, die nicht explizit gesetzt wurden, den gleichen
Wert haben sollen wie die Felder in der gegebenen Instanz.</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from(&quot;jemand@example.com&quot;),
</span><span class="boring">        username: String::from(&quot;benutzername123&quot;),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span><span class="boring">
</span>    let user2 = User {
        email: String::from(&quot;andere@example.com&quot;),
        username: String::from(&quot;andererbenutzername567&quot;),
        ..user1
    };
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 5-7: Verwenden der
Strukturaktualisierungssyntax, um neue Werte für <code>email</code> und <code>username</code> in der
<code>User</code>-Instanz zu setzen und die restlichen Werte aus den Feldern der Instanz
<code>user1</code> zu übernehmen</span></p>
<p>Der Code in Codeblock 5-7 erzeugt auch eine Instanz <code>user2</code>, die andere Werte
für <code>email</code> und <code>username</code> hat, aber die gleichen Werte der Felder <code>active</code> und
<code>sign_in_count</code> wie <code>user1</code>.</p>
<h3><a class="header" href="#verwenden-von-tupel-strukturen-ohne-benannte-felder-um-verschiedene-typen-zu-erzeugen" id="verwenden-von-tupel-strukturen-ohne-benannte-felder-um-verschiedene-typen-zu-erzeugen">Verwenden von Tupel-Strukturen ohne benannte Felder um verschiedene Typen zu erzeugen</a></h3>
<p>Du kannst auch Strukturen definieren, die wie Tupel aussehen, sogenannte
<em>Tupel-Strukturen</em> (tuple structs). Tupel-Strukturen sind Strukturen, die
keine Feldnamen haben, sondern nur die Typen der Felder. Tupel-Strukturen sind
hilfreich, wenn du dem gesamten Tupel einen Namen geben und erreichen willst,
dass das Tupel einen anderen Typ als die anderen Tupel hat und Feldnamen wie in
einer regulären Struktur langatmig oder unnötig wären.</p>
<p>Um eine Tupel-Struktur zu definieren, starte mit dem Schlüsselwort <code>struct</code>,
gefolgt vom Strukturnamen und den Typen im Tupel. Nachfolgend ein Beispiel mit
Definition und Verwendung zweier Tupel-Strukturen <code>Color</code> und <code>Point</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
<span class="boring">}
</span></code></pre></pre>
<p>Beachte, dass die Werte <code>black</code> und <code>origin</code> unterschiedliche Typen haben, weil
sie Instanzen unterschiedlicher Tupel-Strukturen sind. Jede von dir definierte
Struktur ist ein eigenständiger Typ, auch wenn die Felder innerhalb der
Struktur die gleichen Typen haben. Zum Beispiel kann eine Funktion, die einen
Parameter vom Typ <code>Color</code> hat, keinen <code>Point</code> als Argument nehmen, obwohl beide
Typen aus drei <code>i32</code>-Werten bestehen. Ansonsten verhalten sich
Tupel-Struktur-Instanzen wie Tupel: Du kannst sie in ihre Einzelteile zerlegen,
indem du <code>.</code> gefolgt vom Index schreibst, um auf einen einzelnen Wert
zuzugreifen, und so weiter.</p>
<h3><a class="header" href="#einheitstyp" id="einheitstyp">Einheitstyp</a></h3>
<p>Du kannst auch Strukturen definieren, die gar keine Felder haben! Diese werden
<em>Einheitstyp</em> (unit-like structs) genannt, weil sie sich ähnlich zum leeren
Tupel <code>()</code> verhalten. Einheitstypen können in Situationen nützlich sein, in
denen du ein Merkmal (trait) zu einem Typ implementieren musst, du aber keine
Daten hast, die im Typ gespeichert werden sollen. Wir werden Merkmale in
Kapitel 10 besprechen.</p>
<blockquote>
<h3><a class="header" href="#eigentümerschaft-von-strukturdaten" id="eigentümerschaft-von-strukturdaten">Eigentümerschaft von Strukturdaten</a></h3>
<p>In der Strukturdefinition <code>User</code> in Codeblock 5-1 haben wir den Typ <code>String</code>
anstelle von <code>&amp;str</code> verwendet. Dies ist eine bewusste Entscheidung, denn wir
wollen, dass Instanzen dieser Struktur all ihre Daten besitzen und diese
Daten so lange gültig sind, wie die gesamte Struktur gültig ist.</p>
<p>Bei Strukturen ist es möglich, Referenzen auf Daten zu speichern, die im
Besitz von etwas anderem sind, aber das erfordert die Verwendung von
<em>Lebensdauern</em>, einer Rust-Funktionalität, die wir in Kapitel 10 besprechen
werden. Die Lebensdauer stellt sicher, dass die von einer Struktur
referenzierten Daten so lange gültig sind, wie die Struktur gültig ist.
Angenommen, du versuchst eine Referenz in einer Struktur zu speichern, ohne
eine Lebensdauer anzugeben, wird das nicht funktionieren:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">struct User {
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    let user1 = User {
        email: &quot;jemand@example.com&quot;,
        username: &quot;benutzername123&quot;,
        active: true,
        sign_in_count: 1,
    };
}
</code></pre>
<p>Der Compiler wird sich beschweren, dass die Lebensdauer nicht angegeben ist:</p>
<pre><code class="language-text">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:2:15
  |
2 |     username: &amp;str,
  |               ^ expected lifetime parameter

error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:3:12
  |
3 |     email: &amp;str,
  |            ^ expected lifetime parameter

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0106`.
error: could not compile `structs`.

To learn more, run the command again with --verbose.
</code></pre>
<p>In Kapitel 10 werden wir klären, wie man diese Fehler behebt und Referenzen
in Strukturen speichern kann. Aber für den Moment werden wir Fehler wie diese
vermeiden, indem wir Typen wie <code>String</code> anstelle von Referenzen wie <code>&amp;str</code>
verwenden.</p>
</blockquote>
<h2><a class="header" href="#beispielprogramm-mit-strukturen-structs" id="beispielprogramm-mit-strukturen-structs">Beispielprogramm mit Strukturen (structs)</a></h2>
<p>Um besser zu verstehen, wann wir Strukturen verwenden können, schreiben wir ein
Programm, das die Fläche eines Rechtecks berechnet. Wir beginnen mit einzelnen
Variablen und schreiben das Programm dann um, bis wir stattdessen Strukturen
einsetzen.</p>
<p>Legen wir mit Cargo ein neues Binärprojekt namens <em>rectangles</em> an, das die
Breite und Höhe eines in Pixeln angegebenen Rechtecks nimmt und die Fläche des
Rechtecks berechnet.</p>
<p>Codeblock 5-8 zeigt ein kurzes Programm, das genau das in <em>src/main.rs</em> unseres
Projekts macht.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let width1 = 30;
    let height1 = 50;

    println!(
        &quot;Die Fläche des Rechtecks ist {} Quadratpixel.&quot;,
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -&gt; u32 {
    width * height
}
</code></pre></pre>
<p><span class="caption">Codeblock 5-8: Berechnen der Fläche eines Rechtecks, das
durch separate Breiten- und Höhenvariablen beschrieben wird</span></p>
<p>Nun führe dieses Programm mit <code>cargo run</code> aus:</p>
<pre><code class="language-text">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/structs`
Die Fläche des Rechtecks ist 1500 Quadratpixel.
</code></pre>
<p>Auch wenn Codeblock 5-8 funktioniert und die Fläche des Rechtecks durch
Aufrufen der Funktion <code>area</code> mit jeder Dimension herausfindet, können wir es
besser machen. Breite und Höhe hängen zusammen, sie beschreiben zusammen ein
Rechteck.</p>
<p>Das Problem dieses Codes wird bei der Signatur von <code>area</code> deutlich:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    let width1 = 30;
</span><span class="boring">    let height1 = 50;
</span><span class="boring">
</span><span class="boring">    println!(
</span><span class="boring">        &quot;Die Fläche des Rechtecks ist {} Quadratpixel.&quot;,
</span><span class="boring">        area(width1, height1)
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span>fn area(width: u32, height: u32) -&gt; u32 {
<span class="boring">    width * height
</span><span class="boring">}
</span></code></pre>
<p>Die Funktion <code>area</code> soll die Fläche eines Rechtecks berechnen, aber die von uns
geschriebene Funktion hat zwei Parameter. Dass die Parameter zusammenhängen,
wird aber nirgendwo in unserem Programm ausgedrückt. Es wäre besser lesbar und
überschaubarer, Breite und Höhe zusammenzufassen. Eine Möglichkeit dazu haben
wir bereits im Abschnitt <a href="ch03-02-data-types.html#the-tuple-type">„Der Tupeltyp“</a> in Kapitel 3
vorgestellt: Der Einsatz von Tupeln.</p>
<h3><a class="header" href="#refaktorierung-mit-tupeln" id="refaktorierung-mit-tupeln">Refaktorierung mit Tupeln</a></h3>
<p>Codeblock 5-9 zeigt eine weitere Version unseres Programms, die Tupel
verwendet.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let rect1 = (30, 50);

    println!(
        &quot;Die Fläche des Rechtecks ist {} Quadratpixel.&quot;,
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -&gt; u32 {
    dimensions.0 * dimensions.1
}
</code></pre></pre>
<p><span class="caption">Codeblock 5-9: Breite und Höhe des Rechtecks werden mit
einem Tupel beschrieben</span></p>
<p>In einem Punkt ist dieses Programm besser. Das Tupel bringt etwas Struktur
hinein und wir geben jetzt nur noch ein Argument weiter. Andererseits ist
dieser Ansatz weniger deutlich: Tupel benennen ihre Elemente nicht, so dass
unsere Berechnung noch unübersichtlicher geworden ist, weil wir die Teile des
Tupels indizieren müssen.</p>
<p>Es spielt zwar keine Rolle, wenn wir bei der Flächenberechnung Breite und Höhe
verwechseln, aber wenn wir das Rechteck auf dem Bildschirm zeichnen wollten,
würde es eine Rolle spielen! Wir müssten berücksichtigen, dass <code>width</code> den
Tupelindex <code>0</code> und <code>height</code> den Tupelindex <code>1</code> hat. Wenn eine andere Person an
diesem Code arbeiten würde, müsste er das herausfinden und sich das ebenfalls
merken. Es wäre leicht, diese Werte zu vergessen oder zu verwechseln und Fehler
zu verursachen, weil wir die Bedeutung unserer Daten in unserem Code nicht
hinterlegt haben.</p>
<h3><a class="header" href="#refaktorierung-mit-strukturen-mehr-semantik" id="refaktorierung-mit-strukturen-mehr-semantik">Refaktorierung mit Strukturen: Mehr Semantik</a></h3>
<p>Verwenden wir Strukturen, um durch die Benennung der Daten deren Bedeutung
anzugeben. Wir können das verwendete Tupel in einen Datentyp mit einem Namen
für das Ganze sowie mit Namen für die Einzelteile umwandeln, wie in Codeblock
5-10 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        &quot;Die Fläche des Rechtecks ist {} Quadratpixel.&quot;,
        area(&amp;rect1)
    );
}

fn area(rectangle: &amp;Rectangle) -&gt; u32 {
    rectangle.width * rectangle.height
}
</code></pre></pre>
<p><span class="caption">Codeblock 5-10: Definieren der Struktur <code>Rectangle</code></span></p>
<p>Hier haben wir eine Struktur definiert und sie <code>Rectangle</code> genannt. Innerhalb
der geschweiften Klammern haben wir die Felder <code>width</code> und <code>height</code> definiert,
die beide den Typ <code>u32</code> haben. Dann erzeugten wir in <code>main</code> eine Instanz von
<code>Rectangle</code> mit der Breite 30 und Höhe 50.</p>
<p>Unsere Funktion <code>area</code> hat nun einen Parameter, den wir <code>rectangle</code> genannt
haben und dessen Typ eine unveränderliche Ausleihe (immutable borrow) einer
Strukturinstanz <code>Rectangle</code> ist. Wie in Kapitel 4 erwähnt, wollen wir die
Struktur nur ausleihen, nicht aber deren Eigentümerschaft (ownership)
übernehmen. Auf diese Weise behält <code>main</code> seine Eigentümerschaft und kann
weiterhin <code>rect1</code> verwenden, weshalb wir <code>&amp;</code> in der Funktionssignatur und an
der Aufrufstelle verwenden.</p>
<p>Die Funktion <code>area</code> greift auf die Felder <code>width</code> und <code>height</code> der Instanz
<code>Rectangle</code> zu. Unsere Funktionssignatur für <code>area</code> sagt jetzt genau was wir
meinen: Berechne die Fläche von <code>Rectangle</code> unter Verwendung seiner Felder
<code>width</code> und <code>height</code>. Dies drückt aus, dass Breite und Höhe in Beziehung
zueinander stehen, und gibt den Werten beschreibende Namen, ohne die
Tupelindexwerte <code>0</code> und <code>1</code> zu verwenden. Das erhöht die Lesbarkeit.</p>
<h3><a class="header" href="#hilfreiche-funktionalität-mit-abgeleiteten-merkmalen-derived-traits" id="hilfreiche-funktionalität-mit-abgeleiteten-merkmalen-derived-traits">Hilfreiche Funktionalität mit abgeleiteten Merkmalen (derived traits)</a></h3>
<p>Es wäre schön, eine Instanz von <code>Rectangle</code> samt der Werte seiner Felder
ausgeben zu können, während wir unser Programm debuggen. In Codeblock 5-11
versuchen wir das Makro <code>println!</code> zu verwenden, das wir in den vorangegangenen
Kapiteln verwendet haben. Dies wird jedoch nicht funktionieren.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(&quot;rect1 ist {}&quot;, rect1);
}
</code></pre>
<p><span class="caption">Codeblock 5-11: Versuch, eine <code>Rectangle</code>-Instanz
auszugeben</span></p>
<p>Wenn wir diesen Code kompilieren, erhalten wir folgende Fehlermeldung:</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
</code></pre>
<p>Das Makro <code>println!</code> kann diverse Formatierungen vornehmen. Die geschweiften
Klammern weisen <code>println!</code> an, die Formatierung <code>Display</code> zu verwenden, bei der
die Ausgabe direkt für den Endbenutzer bestimmt ist. Die primitiven Typen, die
wir bisher gesehen haben, implementieren <code>Display</code> standardmäßig, denn es gibt
nur eine Möglichkeit, dem Benutzer eine <code>1</code> oder einen anderen primitiven Typ
zu zeigen. Aber bei Strukturen ist die Formatierung, die <code>println!</code> verwenden
soll, weniger klar, da es mehrere Darstellungsmöglichkeiten gibt: Möchtest du
Kommas oder nicht? Möchtest du die geschweiften Klammern ausgeben? Sollen alle
Felder angezeigt werden? Aufgrund der vielen Möglichkeiten versucht Rust nicht
zu erraten, was wir wollen. Strukturen haben daher keine
Standardimplementierung von <code>Display</code>.</p>
<p>Wenn wir die Fehlerausgabe weiterlesen, werden wir diesen hilfreichen Hinweis
finden:</p>
<pre><code class="language-text">   = help: the trait `std::fmt::Display` is not implemented for `Rectangle`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
</code></pre>
<p>Lass es uns versuchen! Der Makroaufruf <code>println!</code> wird geändert in
<code>println!(&quot;rect1 ist {:?}&quot;, rect1);</code>. Wenn wir das Symbol <code>:?</code> innerhalb der
geschweiften Klammern angeben, teilen wir <code>println!</code> mit, dass wir das
Ausgabeformat <code>Debug</code> verwenden wollen. Das Merkmal <code>Debug</code> ermöglicht es, die
Struktur so auszugeben, dass Entwickler ihren Wert erkennen können, während sie
den Code debuggen.</p>
<p>Kompiliere den Code mit dieser Änderung. Verflixt! Wir erhalten immer noch
einen Fehler:</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `std::fmt::Debug`
</code></pre>
<p>Aber auch hier gibt uns der Compiler einen hilfreichen Hinweis:</p>
<pre><code class="language-text">   = help: the trait `std::fmt::Debug` is not implemented for `Rectangle`
   = note: add `#[derive(Debug)]` or manually implement `std::fmt::Debug`
</code></pre>
<p>Rust enthält durchaus eine Funktionalität zum Ausgeben von Debug-Informationen,
aber wir müssen diese explizit für unsere Struktur aktivieren. Dazu fügen wir
die Annotation <code>#[derive(Debug)]</code> unmittelbar vor der Strukturdefinition ein,
wie in Codeblock 5-12 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(&quot;rect1 ist {:?}&quot;, rect1);
}
</code></pre></pre>
<p><span class="caption">Codeblock 5-12: Annotation zum Verwenden des Merkmals
<code>Debug</code> und Ausgeben der Instanz <code>Rectangle</code> mittels Debug-Formatierung</span></p>
<p>Wenn wir das Programm nun ausführen, werden wir keinen Fehler mehr erhalten und
folgende Ausgabe sehen:</p>
<pre><code class="language-text">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/structs`
rect1 ist Rectangle { width: 30, height: 50 }
</code></pre>
<p>Toll! Es ist nicht die schönste Ausgabe, aber sie zeigt die Werte aller Felder
dieser Instanz, was bei der Fehlersuche definitiv hilfreich ist. Bei größeren
Strukturen ist es hilfreich eine Ausgabe zu haben, die etwas leichter zu lesen
ist. In diesen Fällen können wir <code>{:#?}</code> anstelle von <code>{:?}</code> in der
<code>println!</code>-Meldung verwenden. Die Ausgabe sieht dann wie folgt aus:</p>
<pre><code class="language-text">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/structs`
rect1 ist Rectangle {
    width: 30,
    height: 50,
}
</code></pre>
<p>Rust stellt uns eine Reihe von Merkmalen zur Verfügung, die wir mit der
Annotation <code>derive</code> verwenden können, um damit unseren benutzerdefinierten
Typen nützliches Verhalten zu verleihen. Diese Merkmale und ihr Verhalten sind
in Anhang C aufgeführt. In Kapitel 10 werden wir behandeln, wie man diese
Merkmale mit benutzerdefiniertem Verhalten implementiert und wie man eigene
Merkmale erstellt.</p>
<p>Unsere Funktion <code>area</code> ist sehr spezifisch: Sie berechnet nur die Fläche von
Rechtecken. Es wäre hilfreich, dieses Verhalten enger mit unserer Struktur
<code>Rectangle</code> zu verbinden, da es zu keinem anderen Typ passt. Schauen wir uns
an, wie wir den Code weiter umgestalten und unsere Funktion <code>area</code> in eine
<em>Methode</em> <code>area</code> unseres Typs <code>Rectangle</code> verwandeln können.</p>
<h2><a class="header" href="#methodensyntax" id="methodensyntax">Methodensyntax</a></h2>
<p><em>Methoden</em> sind Funktionen recht ähnlich: Sie werden mit dem Schlüsselwort <code>fn</code>
und ihrem Namen deklariert, sie können Parameter und einen Rückgabewert haben,
und sie enthalten etwas Code, der ausgeführt wird, wenn sie aufgerufen werden. 
Methoden unterscheiden sich jedoch von Funktionen dadurch, dass sie im Kontext
einer Struktur (struct) (oder einer Aufzählung (enum) oder eines
Merkmalsobjektes (trait object), die wir in Kapitel 6 und 17 behandeln)
definiert werden und ihr erster Parameter stets <code>self</code> ist. <code>self</code>
repräsentiert die Instanz der Struktur zu der die Methode aufgerufen wird.</p>
<h3><a class="header" href="#definieren-von-methoden" id="definieren-von-methoden">Definieren von Methoden</a></h3>
<p>Lass uns die Funktion <code>area</code>, die eine <code>Rectangle</code>-Instanz als Parameter hat,
ändern und stattdessen eine Methode <code>area</code> auf der Struktur <code>Rectangle</code>
definieren, wie in Codeblock 5-13 zu sehen ist.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        &quot;Die Fläche des Rechtecks ist {} Quadratpixel.&quot;,
        rect1.area()
    );
}
</code></pre></pre>
<p><span class="caption">Codeblock 5-13: Methode <code>area</code> der Struktur <code>Rectangle</code></span></p>
<p>Um die Funktion im Kontext von <code>Rectangle</code> zu definieren, beginnen wir mit dem
Block <code>impl</code> (Implementierung). Dann verschieben wir die Funktion <code>area</code> in die
geschweiften Klammern von <code>impl</code>, ändern den ersten (und in diesem Fall
einzigen) Parameter zu <code>self</code> und passen den Methodenrumpf entsprechend an. In 
<code>main</code>, wo wir die Funktion <code>area</code> aufrufen und <code>rect1</code> als Argument übergeben,
können wir stattdessen die <em>Methodensyntax</em> verwenden, um die Methode <code>area</code>
auf unserer <code>Rectangle</code>-Instanz aufzurufen. Die Methodensyntax bezieht sich auf
eine Instanz: Wir ergänzen einen Punkt, gefolgt vom Methodennamen, Klammern und
Argumenten.</p>
<p>In der Signatur von <code>area</code> verwenden wir <code>&amp;self</code> anstelle von
<code>rectangle: &amp;Rectangle</code>, denn Rust weiß, dass <code>self</code> den Typ <code>Rectangle</code> hat,
da die Methode innerhalb des Kontextes <code>impl Rectangle</code> liegt. Beachte, dass
wir immer noch das <code>&amp;</code> vor <code>self</code> verwenden müssen, so wie wir es bei
<code>&amp;Rectangle</code> getan haben. Methoden können die Eigentümerschaft von <code>self</code>
übernehmen, <code>self</code> unveränderlich ausleihen, wie wir es hier getan haben, oder
<code>self</code> veränderlich ausleihen, so wie bei jedem anderen Parameter auch.</p>
<p>Wir haben hier <code>&amp;self</code> aus dem gleichen Grund gewählt wie <code>&amp;Rectangle</code> in der
Funktionsvariante: Wir wollen keine Eigentümerschaft übernehmen, wir wollen die
Daten der Struktur nur lesen, nicht schreiben. Wenn wir die Instanzdaten ändern
wollten, müssten wir <code>&amp;mut self</code> als ersten Parameter verwenden. Es kommt nur
selten vor, dass eine Methode die Eigentümerschaft der Instanz übernimmt, indem
sie <code>self</code> als ersten Parameter verwendet. Diese Technik wird typischerweise
dann verwendet, wenn die Methode <code>self</code> in etwas anderes transformiert und man
verhindern will, dass der Aufrufer nach der Transformation die ursprüngliche
Instanz verwendet.</p>
<p>Der Hauptvorteil von Methoden gegenüber Funktionen liegt abgesehen davon, dass
bei jeder Methodendeklaration der Typ von <code>self</code> nicht ständig wiederholt
werden muss, in der Organisation. Wir haben alle Dinge, die wir mit einer
Instanz eines Typs tun können, in einen einzigen <code>impl</code> Block gepackt.
Zukünftige Nutzer unseres Codes müssen so nicht an verschiedenen Stellen in der
von uns bereitgestellten Bibliothek nach Fähigkeiten von <code>Rectangle</code> suchen.</p>
<blockquote>
<h3><a class="header" href="#wo-ist-der-operator--" id="wo-ist-der-operator--">Wo ist der Operator <code>-&gt;</code>?</a></h3>
<p>In C und C++ werden zwei verschiedene Operatoren für den Aufruf von Methoden
verwendet: Man verwendet <code>.</code>, wenn eine Methode direkt auf dem Objekt
aufgerufen wird, und <code>-&gt;</code>, wenn die Methode auf einem Zeiger auf das Objekt
aufrufen und der Zeiger zuerst dereferenziert werden muss. Anders gesagt,
wenn <code>object</code> ein Zeiger ist, ist <code>object-&gt;something()</code> ähnlich zu
<code>(*object).something()</code>.</p>
<p>Rust hat kein Äquivalent zum Operator <code>-&gt;</code>. Stattdessen hat Rust eine
Funktionalität namens <em>automatische Referenzierung und Dereferenzierung</em>
(automatic referencing and dereferencing). Der Aufruf von Methoden ist einer
der wenigen Orte in Rust, der dieses Verhalten aufweist.</p>
<p>Und so funktioniert es: Wenn du eine Methode mit <code>object.something()</code>
aufrufst, fügt Rust automatisch <code>&amp;</code>, <code>&amp;mut</code> oder <code>*</code> hinzu, sodass <code>object</code>
zur Signatur der Methode passt. Mit anderen Worten sind folgende Aufrufe
gleich:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug,Copy,Clone)]
</span><span class="boring">struct Point {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Point {
</span><span class="boring">   fn distance(&amp;self, other: &amp;Point) -&gt; f64 {
</span><span class="boring">       let x_squared = f64::powi(other.x - self.x, 2);
</span><span class="boring">       let y_squared = f64::powi(other.y - self.y, 2);
</span><span class="boring">
</span><span class="boring">       f64::sqrt(x_squared + y_squared)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">let p1 = Point { x: 0.0, y: 0.0 };
</span><span class="boring">let p2 = Point { x: 5.0, y: 6.5 };
</span>p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
<span class="boring">}
</span></code></pre></pre>
<p>Der erste Aufruf sieht viel sauberer aus. Die automatische Referenzierung
funktioniert, weil Methoden einen eindeutigen Empfänger haben - den Typ von
<code>self</code>. Wenn man den Empfänger und den Namen einer Methode angibt, kann Rust
eindeutig herausfinden, ob die Methode lesend (<code>&amp;self</code>), veränderlich
(<code>&amp;mut self</code>) oder konsumierend (<code>self</code>) ist. Die Tatsache, dass Rust das
Ausleihen für die Methodenempfänger implizit macht, ist ein großer Beitrag
zur Ergonomie der Eigentümerschaft in der Praxis.</p>
</blockquote>
<h3><a class="header" href="#methoden-mit-mehreren-parametern" id="methoden-mit-mehreren-parametern">Methoden mit mehreren Parametern</a></h3>
<p>Lass uns den Umgang mit Methoden üben, indem wir eine zweite Methode zur
Struktur <code>Rectangle</code> implementieren. Diesmal soll eine zweite Instanz von
<code>Rectangle</code> entgegengenommen und <code>true</code> zurückgeben werden, wenn das zweite
<code>Rectangle</code> vollständig in <code>self</code> hineinpasst; andernfalls soll <code>false</code>
zurückgegeben werden. Das heißt, wir wollen in der Lage sein, das in Codeblock
5-14 gezeigte Programm zu schreiben, sobald wir die Methode <code>can_hold</code>
definiert haben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!(&quot;Umfasst rect1 rect2? {}&quot;, rect1.can_hold(&amp;rect2));
    println!(&quot;Umfasst rect1 rect3? {}&quot;, rect1.can_hold(&amp;rect3));
}
</code></pre>
<p><span class="caption">Codeblock 5-14: Verwendung der noch nicht geschriebenen
Methode <code>can_hold</code></span></p>
<p>Die erwartete Ausgabe würde wie folgt aussehen, da beide Dimensionen von
<code>rect2</code> kleiner als die Dimensionen von <code>rect1</code> sind, aber <code>rect3</code> breiter als
<code>rect1</code> ist:</p>
<pre><code class="language-text">Umfasst rect1 rect2? true
Umfasst rect1 rect3? false
</code></pre>
<p>Wir wissen, dass wir eine Methode definieren wollen, also wird sie innerhalb
des Blocks <code>impl Rectangle</code> liegen. Die Methode wird <code>can_hold</code> heißen und sie
wird einen weiteren Parameter vom Typ <code>Rectangle</code> unveränderlich ausleihen. Wir
können den Typ des Parameters erkennen, indem wir uns den Code ansehen, der die
Methode aufruft: <code>rect1.can_hold(&amp;rect2)</code> nimmt <code>&amp;rect2</code> entgegen, also eine
unveränderliche Ausleihe von <code>rect2</code> vom Typ <code>Rectangle</code>. Das macht Sinn, da
wir <code>rect2</code> nur lesen müssen (anstatt zu schreiben, wofür wir eine
veränderliche Ausleihe bräuchten) und <code>main</code> die Eigentümerschaft an <code>rect2</code>
zurückerhalten soll, so dass wir es nach dem Aufruf der Methode <code>can_hold</code>
weiter verwenden können. Der Rückgabewert von <code>can_hold</code> ist ein boolescher
Wert und die Implementierung prüft, ob Breite und Höhe von <code>self</code> jeweils
größer als von <code>Rectangle</code> sind. Fügen wir die neue Methode <code>can_hold</code> zum
Block <code>impl</code> aus Codeblock 5-13 hinzu, wie in Codeblock 5-15 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!(&quot;Umfasst rect1 rect2? {}&quot;, rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!(&quot;Umfasst rect1 rect3? {}&quot;, rect1.can_hold(&amp;rect3));
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 5-15: Implementierung der Methode <code>can_hold</code>
auf <code>Rectangle</code>, die eine weitere <code>Rectangle</code>-Instanz als Parameter hat</span></p>
<p>Wenn wir diesen Code mit der Funktion <code>main</code> in Codeblock 5-14 ausführen,
erhalten wir die gewünschte Ausgabe. Methoden können mehrere Parameter haben,
die wir in der Signatur nach dem Parameter <code>self</code> angeben. Diese Parameter
funktionieren genau wie Parameter in Funktionen.</p>
<h3><a class="header" href="#assoziierte-funktionen" id="assoziierte-funktionen">Assoziierte Funktionen</a></h3>
<p>Eine weitere nützliche Funktionalität von <code>impl</code>-Blöcken ist, dass wir darin
auch Funktionen <em>ohne</em> den Parameter <code>self</code> definieren können. Diese werden
<em>assoziierte Funktionen</em> (associated functions) genannt, weil sie mit der
Struktur assoziiert sind. Dabei handelt es sich um Funktionen, nicht um
Methoden, weil sie nicht auf einer Instanz der Struktur arbeiten können. Du
hast bereits die assoziierte Funktion <code>String::from</code> verwendet.</p>
<p>Assoziierte Funktionen werden oft als Konstruktoren verwendet, die eine neue
Instanz der Struktur zurückgeben. Zum Beispiel könnten wir eine assoziierte
Funktion bereitstellen, die einen eindimensionalen Parameter hat und diesen
sowohl als Breite als auch als Höhe verwendet, wodurch auf einfache Weise ein
quadratisches <code>Rectangle</code> erzeugt werden kann, ohne denselben Wert zweimal
angeben zu müssen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn square(size: u32) -&gt; Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let sq = Rectangle::square(3);
</span><span class="boring">}
</span></code></pre></pre>
<p>Um diese assoziierte Funktion aufzurufen, verwenden wir die Syntax <code>::</code> mit dem
Strukturnamen, z.B. <code>let sq = Rectangle::square(3);</code>. Diese Funktion gehört zum
Namensraum der Struktur: Die Syntax <code>::</code> wird sowohl für assoziierte Funktionen
als auch für Namensräume, die von Modulen erzeugt werden, verwendet. Wir werden
die Module in Kapitel 7 besprechen.</p>
<h3><a class="header" href="#mehrere-impl-blöcke" id="mehrere-impl-blöcke">Mehrere <code>impl</code>-Blöcke</a></h3>
<p>Jede Struktur darf mehrere <code>impl</code>-Blöcke haben. Beispielsweise entspricht
Codeblock 5-15 dem in Codeblock 5-16 gezeigten Code, bei dem jede Methode in
einem eigenen <code>impl</code>-Block steht.</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!(&quot;Umfasst rect1 rect2? {}&quot;, rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!(&quot;Umfasst rect1 rect3? {}&quot;, rect1.can_hold(&amp;rect3));
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 5-16: Neuschreiben von Codeblock 5-15 unter
Verwendung mehrerer <code>impl</code>-Blöcke</span></p>
<p>Es ist nicht nötig, diese Methoden hier auf mehrere <code>impl</code>-Blöcke zu verteilen,
aber es handelt sich um eine gültige Syntax. Wir werden in Kapitel 10 einen
Fall sehen, bei dem mehrere <code>impl</code>-Blöcke hilfreich sind, wenn wir generische
Typen und Merkmale behandeln.</p>
<h2><a class="header" href="#zusammenfassung-1" id="zusammenfassung-1">Zusammenfassung</a></h2>
<p>Mit Strukturen kannst du benutzerdefinierte Typen erstellen, die in deiner
Domäne eine Bedeutung haben. Durch die Verwendung von Strukturen kannst du
zusammengehörige Datenteile miteinander verbunden halten und jedes Teil
benennen, um deinen Code verständlich zu machen. Mit Methoden kannst du das
Verhalten von Instanzen deiner Strukturen spezifizieren und mit assoziierten
Funktionen kannst du Funktionalität zum Namensraum deiner Struktur hinzufügen,
die ohne Instanz auskommen.</p>
<p>Aber Strukturen sind nicht die einzige Möglichkeit, benutzerdefinierte Typen zu
definieren: Wenden wir uns der Rust-Funktionalität Aufzählung zu, um ein
weiteres Werkzeug in deinen Werkzeugkasten zu legen.</p>
<h1><a class="header" href="#aufzählungen-enums-und-musterabgleich-pattern-matching" id="aufzählungen-enums-und-musterabgleich-pattern-matching">Aufzählungen (enums) und Musterabgleich (pattern matching)</a></h1>
<p>In diesem Kapitel werden wir uns mit <em>Aufzählungen</em> (enumerations, kurz: enums)
befassen. Aufzählungen erlauben es, einen Typ durch Aufzählung seiner möglichen
<em>Varianten</em> (variants) zu definieren. Zuerst werden wir eine Aufzählung
definieren und verwenden, um zu zeigen, wie eine Aufzählung mit Daten eine
Bedeutung kodieren kann. Als Nächstes werden wir eine besonders nützliche
Aufzählung untersuchen, die <code>Option</code> genannt wird und zum Ausdruck bringt, dass
ein Wert entweder etwas oder nichts sein kann. Dann sehen wir uns an, wie man
mit dem Musterabgleich (pattern matching) im Ausdruck <code>match</code> auf einfache
Weise unterschiedlichen Code für verschiedene Werte einer Aufzählung
auszuführen kann. Schließlich werden wir uns mit dem Konstrukt <code>if let</code>
befassen, einem weiteren bequemen und prägnanten Idiom, das dir zur Verfügung
steht, um mit Aufzählungen in deinem Code umzugehen.</p>
<p>Aufzählungen sind eine Funktionalität in vielen Sprachen, aber deren
Möglichkeiten unterscheiden sich in jeder Sprache. Rusts Aufzählungen sind den
<em>algebraischen Datentypen</em> in funktionalen Sprachen wie F#, OCaml und Haskell
am ähnlichsten.</p>
<h2><a class="header" href="#eine-aufzählung-enum-definieren" id="eine-aufzählung-enum-definieren">Eine Aufzählung (enum) definieren</a></h2>
<p>Schauen wir uns eine Situation an, die wir mit Code ausdrücken wollen, bei der
Aufzählungen (enums) nützlich und geeigneter sind als Strukturen (structs).
Angenommen, wir müssen mit IP-Adressen arbeiten. Aktuell werden zwei
Hauptstandards für IP-Adressen verwendet: Version vier und Version sechs. Das
sind die einzigen Möglichkeiten einer IP-Adresse, mit denen unser Programm zu
tun haben wird: Wir können alle möglichen Varianten <em>aufzählen</em>, daher auch der
Name der Aufzählung.</p>
<p>Jede IP-Adresse kann entweder eine Adresse der Version vier oder der Version
sechs sein, aber nicht beides gleichzeitig. Diese Eigenschaft der IP-Adressen
passt zur Aufzählungs-Datenstruktur, da Aufzählungswerte nur eine ihrer
Varianten sein können. Sowohl die Adressen der Version vier als auch der
Version sechs sind grundsätzlich immer noch IP-Adressen, so dass sie als der
gleiche Typ behandelt werden sollten, wenn der Code mit Situationen zu tun hat,
die für beide IP-Adressenarten gelten.</p>
<p>Wir können dieses Konzept im Code ausdrücken, indem wir eine Aufzählung
<code>IpAddrKind</code> definieren und die möglichen Varianten auflisten, die eine
IP-Adresse haben kann, <code>V4</code> und <code>V6</code>. Hier die Varianten der Aufzählung:</p>
<pre><pre class="playpen"><code class="language-rust">enum IpAddrKind {
    V4,
    V6,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}
</span></code></pre></pre>
<p><code>IpAddrKind</code> ist jetzt ein benutzerdefinierter Datentyp, den wir an anderer
Stelle in unserem Code verwenden können.</p>
<h3><a class="header" href="#werte-in-aufzählungen" id="werte-in-aufzählungen">Werte in Aufzählungen</a></h3>
<p>Wir können Instanzen von beiden Varianten von <code>IpAddrKind</code> wie folgt erstellen:</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
<span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}
</span></code></pre></pre>
<p>Beachte, dass die Varianten der Aufzählung mit dem Namensraum des Bezeichners
angegeben sind und wir einen doppelten Doppelpunkt verwenden, um die beiden zu
trennen. Das ist sinnvoll, weil beide Werte <code>IpAddrKind::V4</code> und
<code>IpAddrKind::V6</code> vom gleichen Typ sind: <code>IpAddrKind</code>. Wir können dann zum
Beispiel eine Funktion definieren, die jedes <code>IpAddrKind</code> annimmt:</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span>fn route(ip_kind: IpAddrKind) {}
</code></pre></pre>
<p>Und wir können diese Funktion mit beiden Varianten aufrufen:</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span>    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}
</span></code></pre></pre>
<p>Aufzählungen haben noch weitere Vorteile. Wenn wir weiter über unseren
IP-Adresstyp nachdenken, haben wir im Moment keine Möglichkeit, den <em>Wert</em> der
tatsächlichen IP-Adresse zu speichern; wir wissen nur, um welche <em>Variante</em> es
sich handelt. Mit dem was du gerade erst in Kapitel 5 über Strukturen gelernt
hast, könntest du dieses Problem wie in Codeblock 6-1 dargestellt angehen.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum IpAddrKind {
    V4,
    V6,
}

struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from(&quot;127.0.0.1&quot;),
};

let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from(&quot;::1&quot;),
};
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 6-1: Speichern des Wertes und der
<code>IpAddrKind</code>-Variante einer IP-Adresse mittels <code>struct</code></span></p>
<p>Hier haben wir eine Struktur <code>IpAddr</code> definiert, die zwei Felder hat:  Ein Feld
<code>kind</code> vom Typ <code>IpAddrKind</code> (die zuvor definierte Aufzählung) und ein Feld
<code>address</code> vom Typ <code>String</code>. Wir haben zwei Instanzen dieser Struktur erzeugt.
Die erste, <code>home</code>, hat die Variante <code>IpAddrKind::V4</code> und die zugehörige Adresse
<code>127.0.0.1</code>. Die zweite Instanz, <code>loopback</code>, hat die Variante <code>V6</code> von
<code>IpAddrKind</code> als ihren Wert für <code>kind</code> und die zugehörige Adresse <code>::1</code>. Wir
haben eine Struktur verwendet, um die Werte <code>kind</code> und <code>address</code> zu bündeln, so
dass jetzt die Variante mit dem Wert verbunden ist.</p>
<p>Wir können dasselbe Konzept prägnanter darstellen, indem wir nur eine
Aufzählung, anstelle einer Aufzählung innerhalb einer Struktur, verwenden,
indem wir Daten direkt in jede Aufzählungsvariante einfügen. Diese neue
Definition der Aufzählung <code>IpAddr</code> legt fest, dass sowohl die Variante <code>V4</code> als
auch <code>V6</code> zugehörige <code>String</code>-Werte haben:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from(&quot;127.0.0.1&quot;));

let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>Wir hängen die Daten direkt an jede Variante der Aufzählung an, so dass keine
zusätzliche Struktur erforderlich ist.</p>
<p>Es gibt noch einen weiteren Vorteil, eine Aufzählung statt einer Struktur zu
verwenden: Jede Variante kann verschiedene Typen und verschieden viele
zugehöriger Daten haben. IP-Adressen der Version vier haben stets vier
numerische Komponenten, die Werte zwischen 0 und 255 haben. Wenn wir
<code>V4</code>-Adressen als vier <code>u8</code>-Werte speichern und <code>V6</code>-Adressen als einen
<code>String</code>-Wert ausdrücken wollten, wäre das mit einer Struktur nicht möglich.
Aufzählungen lösen diesen Fall ganz einfach:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>Wir haben verschiedene Möglichkeiten zur Definition von Datenstrukturen
gezeigt, die Version vier und sechs einer IP-Adresse speichern können.
Wie sich jedoch herausstellt, ist der Wunsch, IP-Adressen inklusive deren
Variante zu speichern, so verbreitet, dass <a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">die Standardbibliothek eine
Definition bereitstellt</a>, die wir verwenden können! Schauen wir uns an,
wie die Standardbibliothek <code>IpAddr</code> definiert: Es hat genau die Aufzählung und
die Varianten, die wir definiert und verwendet haben, aber es bettet die
Adressdaten innerhalb der Varianten in Form von zwei verschiedenen Strukturen
ein, die für jede Variante unterschiedlich definiert sind:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
<span class="boring">}
</span></code></pre></pre>
<p>Dieser Code veranschaulicht, dass du jede Art von Daten in eine
Aufzählungsvariante einfügen kannst: Zeichenketten, numerische Typen,
Strukturen usw. Du kannst sogar eine weitere Aufzählung einfügen! Außerdem sind
Standardbibliothekstypen oft nicht viel komplizierter als das, was du dir
vielleicht ausdenkst. Beachte, dass wir, obwohl die Standardbibliothek eine
Definition für <code>IpAddr</code> enthält, konfliktfrei unsere eigene Definition
erstellen und verwenden können, da wir die Definition der Standardbibliothek
nicht in unseren Gültigkeitsbereich aufgenommen haben. Wir werden in Kapitel 7
mehr darauf eingehen, wie man Typen in den Gültigkeitsbereich aufnimmt.</p>
<p>Schauen wir uns ein weiteres Beispiel für eine Aufzählung in Codeblock 6-2 an:
In dieser Aufzählung ist eine Vielzahl von Typen in ihren Varianten eingebettet.</p>
<pre><pre class="playpen"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 6-2: Eine Aufzählung <code>Message</code>, deren Varianten
jeweils eine unterschiedliche Anzahl an Werttypen speichern</span></p>
<p>Diese Aufzählung hat vier Varianten mit unterschiedlichen Typen:</p>
<ul>
<li><code>Quit</code> hat überhaupt keine Daten.</li>
<li><code>Move</code> enthält eine anonyme Struktur.</li>
<li><code>Write</code> enthält einen einzelnen <code>String</code>.</li>
<li><code>ChangeColor</code> enthält drei <code>i32</code>-Werte.</li>
</ul>
<p>Die Definition einer Aufzählung mit Varianten wie in Codeblock 6-2 ist ähnlich
zur Definition verschiedener Arten von Strukturdefinitionen, außer dass die
Aufzählung nicht das Schlüsselwort <code>struct</code> verwendet und alle Varianten unter
dem Typ <code>Message</code> zusammengefasst sind. Die folgenden Strukturen könnten die
gleichen Daten aufnehmen wie die vorhergehenden Aufzählungsvarianten:</p>
<pre><pre class="playpen"><code class="language-rust">struct QuitMessage; // leere Struktur
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // Tupelstruktur
struct ChangeColorMessage(i32, i32, i32); // Tupelstruktur
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Aber wenn wir die verschiedenen Strukturen verwenden würden, die jeweils ein
eigener Typ sind, könnten wir nicht so einfach eine Funktion definieren, die
eine dieser Nachrichtenarten entgegennimmt, wie wir es mit der in Codeblock 6-2
definierten Aufzählung <code>Message</code> gemacht haben, bei der es sich um einen
einzigen Typ handelt.</p>
<p>Es gibt noch eine weitere Ähnlichkeit zwischen Aufzählungen und Strukturen: So
wie wir Methoden für Strukturen mit <code>impl</code> definieren können, können wir auch
Methoden für Aufzählungen definieren. Hier ist eine Methode namens <code>call</code>, die
wir für unsere Aufzählung <code>Message</code> definieren könnten:</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    enum Message {
</span><span class="boring">        Quit,
</span><span class="boring">        Move { x: i32, y: i32 },
</span><span class="boring">        Write(String),
</span><span class="boring">        ChangeColor(i32, i32, i32),
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Message {
        fn call(&amp;self) {
            // Methodenrumpf
        }
    }

    let m = Message::Write(String::from(&quot;hallo&quot;));
    m.call();
<span class="boring">}
</span></code></pre></pre>
<p>Der Methodenrumpf würde <code>self</code> benutzen, um den Wert zu erhalten, auf den wir
die Methode aufgerufen haben. In diesem Beispiel haben wir eine Variable <code>m</code>
erstellt, die den Wert <code>Message::Write(String::from(&quot;hallo&quot;))</code> hat. Genau
diesen Wert wird <code>self</code> im Rumpf der Methode <code>call</code> haben, wenn <code>m.call()</code>
ausgeführt wird.</p>
<p>Sehen wir uns eine weitere Aufzählung in der Standardbibliothek an, die sehr
verbreitet und hilfreich ist: <code>Option</code></p>
<h3><a class="header" href="#die-aufzählung-option-und-ihre-vorteile-gegenüber-nullwerten" id="die-aufzählung-option-und-ihre-vorteile-gegenüber-nullwerten">Die Aufzählung <code>Option</code> und ihre Vorteile gegenüber Nullwerten</a></h3>
<p>Im vorigen Abschnitt haben wir uns angesehen, wie es die Aufzählung <code>IpAddr</code>
ermöglicht, Rusts Typsystem zu verwenden, um mehr Informationen als nur die
Daten in unserem Programm zu kodieren. Dieser Abschnitt befasst sich mit einer
Fallstudie zu <code>Option</code>, einer weiteren Aufzählung, die von der
Standardbibliothek definiert wird. Der Typ <code>Option</code> wird an vielen Stellen
verwendet, weil er das sehr häufige Szenario abbildet, in dem ein Wert etwas
oder nichts sein könnte. Im Sinne des Typsystems bedeutet das, dass der
Kompilierer überprüfen kann, ob du alle Fälle behandelt hast, die du behandelt
sollst. Diese Funktionalität kann Fehler vermeiden, die in anderen
Programmiersprachen extrem häufig auftreten.</p>
<p>Bei der Entwicklung von Programmiersprachen wird oft überlegt, welche
Funktionalität aufgenommen werden soll, aber auch die auszuschließende
Funktionalität ist wichtig. Rust hat nicht die Funktionalität „null“, die es in
vielen anderen Sprachen gibt. <em>Null</em> ist ein Wert, der bedeutet, dass kein Wert
vorhanden ist. In Sprachen mit null können sich Variablen immer in einem von
zwei Zuständen befinden: null oder nicht null.</p>
<p>In seinem Vortrag „Nullreferenzen: Der milliardenschwere Fehler“ von 2009 hat
Tony Hoare, der Erfinder von null, folgendes gesagt:</p>
<blockquote>
<p>Ich nenne es meinen milliardenschweren Fehler. Zu dieser Zeit entwarf ich das
erste umfangreiche Typsystem für Referenzen in einer objektorientierten
Sprache. Mein Ziel war es, sicherzustellen, dass jede Verwendung von
Referenzen absolut sicher sein sollte, wobei die Überprüfung automatisch
durch den Kompilierer durchgeführt wird. Aber ich konnte der Versuchung nicht
widerstehen, eine Nullreferenz einzuführen, nur weil sie so einfach
umzusetzen war. Dies hat zu unzähligen Fehlern, Schwachstellen und
Systemabstürzen geführt, die in den letzten vierzig Jahren wahrscheinlich
eine Milliarde Dollar Schmerz und Schaden verursacht haben.</p>
</blockquote>
<p>Das Problem mit Nullwerten besteht darin, dass du einen Fehler erhältst, wenn
du versuchst, einen Nullwert als Nicht-Nullwert zu verwenden. Da diese Null-
oder Nicht-Null-Eigenschaft allgegenwärtig ist, ist es extrem einfach, einen
derartigen Fehler zu machen.</p>
<p>Das Konzept, das die Null zum Ausdruck bringen will, ist jedoch nach wie vor
nützlich: Null ist ein Wert, der aktuell ungültig ist oder aus irgendeinem
Grund nicht vorhanden ist.</p>
<p>Das Problem liegt nicht wirklich im Konzept, sondern in der konkreten
Umsetzung. Als solches hat Rust keine Nullen, aber es hat eine Aufzählung, die
das Konzept des Vorhandenseins oder Nichtvorhandenseins eines Wertes abbilden
kann. Diese Aufzählung heißt <code>Option&lt;T&gt;</code> und ist
<a href="https://doc.rust-lang.org/std/option/enum.Option.html">in der Standardbibliothek</a> wie folgt definiert:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}
</span></code></pre></pre>
<p>Die Aufzählung <code>Option&lt;T&gt;</code> ist so nützlich, dass sie sogar im Präludium
enthalten ist; du musst sie nicht explizit in den Anwendungsbereich aufnehmen.
Dasselbe gilt für ihre Varianten: Du kannst <code>Some</code> und <code>None</code> direkt ohne
Präfix <code>Option::</code> verwenden. Die Aufzählung <code>Option&lt;T&gt;</code> ist dennoch nur eine
normale Aufzählung, und <code>Some(T)</code> und <code>None</code> sind nur Varianten des Typs
<code>Option&lt;T&gt;</code>.</p>
<p>Die Syntax <code>&lt;T&gt;</code> ist eine Funktionalität von Rust, über die wir noch nicht
gesprochen haben. Es handelt sich um einen generischen Typparameter, auf den
wir in Kapitel 10 näher eingehen werden. Für den Moment musst du nur wissen,
dass <code>&lt;T&gt;</code> bedeutet, dass die Variante <code>Some</code> der Aufzählung <code>Option</code> einen
Wert eines beliebigen Typs enthalten kann. Hier sind einige Beispiele für die
Verwendung von <code>Option</code>-Werten zur Aufnahme von Zahlentypen und
Zeichenkettentypen:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let some_number = Some(5);
let some_string = Some(&quot;eine Zeichenkette&quot;);

let absent_number: Option&lt;i32&gt; = None;
<span class="boring">}
</span></code></pre></pre>
<p>Wenn wir <code>None</code> anstelle von <code>Some</code> verwenden, müssen wir Rust sagen, welchen
Typ von <code>Option&lt;T&gt;</code> wir haben, weil der Compiler nicht auf den Typ schließen
kann, den die Variante <code>Some</code> haben soll, wenn er nur einen Wert <code>None</code> sieht.</p>
<p>Wenn wir einen Wert <code>Some</code> haben, wissen wir, dass ein Wert vorhanden ist und
der Wert innerhalb von <code>Some</code> gehalten wird. Wenn wir einen Wert <code>None</code> haben,
bedeutet das in gewisser Weise dasselbe wie Null: Wir haben keinen gültigen
Wert. Warum ist nun besser <code>Option&lt;T&gt;</code> anstelle von Null zu verwenden?</p>
<p>Kurz gesagt, weil <code>Option&lt;T&gt;</code> und <code>T</code> (wobei <code>T</code> ein beliebiger Typ sein kann)
unterschiedliche Typen sind, erlaubt es der Kompilierer nicht <code>Option&lt;T&gt;</code> so zu
verwenden als wäre es definitiv ein gültiger Wert. Beispielsweise lässt sich
dieser Code nicht kompilieren, weil er versucht, ein <code>i8</code> mit einem
<code>Option&lt;i8&gt;</code> zu addieren:</p>
<pre><code class="language-rust ignore does_not_compile">let x: i8 = 5;
let y: Option&lt;i8&gt; = Some(5);

let sum = x + y;
</code></pre>
<p>Wenn wir diesen Code ausführen, erhalten wir eine Fehlermeldung wie diese:</p>
<pre><code class="language-text">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `std::option::Option&lt;i8&gt;` to `i8`
 --&gt; src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + std::option::Option&lt;i8&gt;`
  |
  = help: the trait `std::ops::Add&lt;std::option::Option&lt;i8&gt;&gt;` is not implemented for `i8`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Stark! Tatsächlich bedeutet diese Fehlermeldung, dass Rust nicht versteht, wie
man ein <code>i8</code> und eine <code>Option&lt;i8&gt;</code> addiert, da es sich um unterschiedliche Typen
handelt. Wenn wir einen Wert eines Typs wie <code>i8</code> in Rust haben, stellt der
Kompilierer sicher, dass wir immer einen gültigen Wert haben. Wir können mit
Zuversicht vorgehen, ohne vor der Verwendung dieses Wertes auf Null prüfen zu
müssen. Nur wenn wir eine <code>Option&lt;i8&gt;</code> (oder einen anderen Werttyp) haben,
müssen wir befürchten, dass wir möglicherweise keinen Wert haben, und der
Kompilierer wird sicherstellen, dass wir diesen Fall behandeln, bevor wir den
Wert verwenden.</p>
<p>Mit anderen Worten musst du eine <code>Option&lt;T&gt;</code> in ein <code>T</code> konvertieren, bevor du
<code>T</code>-Operationen damit durchführen kannst. Im Allgemeinen hilft dies, eines der
häufigsten Probleme mit Null abzufangen: Anzunehmen, dass etwas nicht null ist,
obwohl es tatsächlich null ist.</p>
<p>Wenn du dir keine Sorgen machen musst, dass fälschlicherweise ein
Nicht-Null-Wert angenommen wird, hilft dir das mehr Vertrauen in deinen Code zu
haben. Um einen Wert zu haben, der möglicherweise null sein kann, musst du dich
explizit dafür entscheiden, indem du als Typ <code>Option&lt;T&gt;</code> verwendest. Wenn du
dann diesen Wert verwendest, musst du den Fall null explizit behandeln. Überall
dort, wo ein Wert nicht den Typ <code>Option&lt;T&gt;</code> hat, kannst du <em>sicher</em> sein, dass
der Wert nicht null ist. Dies war eine bewusste Konstruktionsentscheidung bei 
Rust, um die Verbreitung von Null einzuschränken und die Sicherheit von
Rust-Code zu erhöhen.</p>
<p>Wie erhältst du nun den <code>T</code>-Wert aus einer Variante <code>Some</code>, wenn du einen Wert
vom Typ <code>Option&lt;T&gt;</code> hast? Die Aufzählung <code>Option&lt;T&gt;</code> enthält eine große Anzahl
von Methoden, die in einer Vielzahl von Situationen nützlich sind; mehr dazu
findest du in <a href="https://doc.rust-lang.org/std/option/enum.Option.html">der Dokumentation</a>. Sich mit den Methoden von <code>Option&lt;T&gt;</code>
vertraut zu machen, wird dir auf deiner Reise mit Rust äußerst nützlich sein.</p>
<p>Um einen <code>Option&lt;T&gt;</code>-Wert zu verwenden, benötigst du im Allgemeinen Code, der
jede Variante behandelt. Du möchtest einen Code, der nur läuft, wenn du einen
Wert <code>Some(T)</code> hast, und dieser Code darf das innere <code>T</code> benutzen. Du möchtest,
dass ein anderer Code ausgeführt wird, wenn du einen Wert <code>None</code> hast, und
dieser Code hat keinen <code>T</code>-Wert. Der Ausdruck <code>match</code> ist ein
Kontrollflusskonstrukt, das genau dies tut, wenn es mit Aufzählungen verwendet
wird: Es führt unterschiedlichen Code aus, je nachdem, welche Variante der
Aufzählung es hat, und dieser Code kann die Daten innerhalb des passenden
Wertes verwenden.</p>
<h2><a class="header" href="#der-kontrollflussoperator-match" id="der-kontrollflussoperator-match">Der Kontrollflussoperator <code>match</code></a></h2>
<p>Rust verfügt über einen extrem leistungsfähigen Kontrollflussoperator namens
<code>match</code>, der es dir ermöglicht, einen Wert mit einer Reihe von Mustern
abzugleichen und dann Code zum jeweils passenden Muster auszuführen. Muster
können sich aus Literalen, Variablennamen, Platzhaltern und vielen anderen
Dingen zusammensetzen. Kapitel 18 befasst sich mit all den verschiedenen
Musterarten und wie sie funktionieren. Die Mächtigkeit von <code>match</code> kommt von
der Ausdruckskraft der Muster und der Tatsache, dass der Kompilierer
sicherstellt, dass alle möglichen Fälle behandelt werden.</p>
<p>Stelle dir einen <code>match</code>-Ausdruck wie eine Münzsortiermaschine vor:  Die Münzen
rutschen eine Bahn mit unterschiedlich großen Löchern entlang, und jede Münze
fällt durch das erste Loch, in das sie hineinpasst. Auf die gleiche Weise
durchlaufen die Werte die Muster in einem <code>match</code>-Ausdruck und beim ersten
„passenden“ Muster fällt der Wert in den zugehörigen Codeblock, der ausgeführt
werden soll.</p>
<p>Da wir eben Münzen erwähnt haben, nehmen wir sie als Beispiel für die
Verwendung von <code>match</code>! Wir können eine Funktion schreiben, die eine unbekannte
Münze der Vereinigten Staaten nimmt und, ähnlich wie die Zählmaschine,
bestimmt, um welche Münze es sich handelt und ihren Wert in Cent zurückgibt,
wie hier in Codeblock 6-3 gezeigt.</p>
<pre><pre class="playpen"><code class="language-rust">enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 6-3: Eine Aufzählung und ein <code>match</code>-Ausdruck,
der die Varianten der Aufzählung als Muster hat</span></p>
<p>Lass uns den <code>match</code>-Ausdruck in der Funktion <code>value_in_cents</code> aufschlüsseln. 
Zuerst geben wir das Schlüsselwort <code>match</code> an, gefolgt von einem Ausdruck, der
in diesem Fall der Wert <code>coin</code> ist. Dies scheint einem Ausdruck sehr ähnlich zu
sein, der bei <code>if</code> verwendet wird, aber es gibt einen großen Unterschied: Bei
<code>if</code> muss der Ausdruck einen booleschen Wert zurückgeben, aber hier kann es
sich um einen beliebigen Typ handeln. Der Typ von <code>coin</code> ist in diesem Beispiel
die Aufzählung <code>Coin</code>, die wir in Zeile 1 definiert haben.</p>
<p>Als nächstes kommen die <code>match</code>-Zweige. Ein Zweig hat zwei Teile: Ein Muster
und etwas Code. Der erste Zweig hat als Muster den Wert <code>Coin::Penny</code>, dann den
Operator <code>=&gt;</code>, der das Muster und den auszuführenden Code trennt. Der Code ist
in diesem Fall nur der Wert <code>1</code>. Jeder Zweig wird durch ein Komma vom nächsten
getrennt.</p>
<p>Wenn der <code>match</code>-Ausdruck ausgeführt wird, gleicht er den resultierenden Wert
mit dem Muster jedes Zweigs ab, und zwar der Reihe nach. Wenn ein Muster zum
Wert passt, wird der zu diesem Muster gehörende Code ausgeführt. Wenn das
Muster nicht zum Wert passt, wird die Ausführung beim nächsten Zweig
fortgesetzt, ähnlich wie bei einer Münzsortiermaschine. Wir können so viele
Zweige haben, wie wir brauchen: In Codeblock 6-3 hat unser <code>match</code>-Ausdruck
vier Zweige.</p>
<p>Der zu jedem Zweig gehörende Code ist ein Ausdruck, und der resultierende Wert
des Ausdrucks im zugehörenden Zweig ist der Wert, der für den gesamten
<code>match</code>-Ausdruck zurückgegeben wird. </p>
<p>Geschweifte Klammern werden in der Regel nicht verwendet, wenn der Zweig-Code
kurz ist, so wie in Codeblock 6-3, wo jeder Zweig nur einen Wert zurückgibt.
Wenn du mehrere Codezeilen in einem Zweig ausführen möchtest, kannst du
geschweifte Klammern verwenden. Zum Beispiel würde der folgende Code jedes Mal
&quot;Glückspfennig!&quot; ausgeben, wenn die Methode mit <code>Coin::Penny</code> aufgerufen wird,
aber immer noch als letzten Wert des Blocks <code>1</code> zurückgeben:</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter,
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; {
            println!(&quot;Glückspfennig!&quot;);
            1
        }
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<h3><a class="header" href="#muster-die-werte-binden" id="muster-die-werte-binden">Muster, die Werte binden</a></h3>
<p>Ein weitere nützliche Funktionalität von <code>match</code>-Zweigen ist, dass sie Teile
der Werte binden können, die dem Muster entsprechen. Auf diese Weise können wir
Werte aus Aufzählungsvarianten extrahieren.</p>
<p>Lass uns als Beispiel eine unserer Aufzählungsvarianten so ändern, dass sie
Daten enthält. Von 1999 bis 2008 prägten die Vereinigten Staaten 25-Cent-Münzen
mit unterschiedlichem Aussehen auf einer Seite für jeden der 50 Staaten. Keine
andere Münze hatte ein Staaten-spezifisches Aussehen, sodass nur 25-Cent-Münzen
diese zusätzliche Eigenschaft haben. Wir können diese Information in unserer
Aufzählung unterbringen, indem wir die Variante <code>Quarter</code> so ändern, dass sie
einen <code>UsState</code>-Wert enthält, wie in Codeblock 6-4 umgesetzt.</p>
<pre><pre class="playpen"><code class="language-rust">enum UsState {
    Alabama,
    Alaska,
    // --abschneiden--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 6-4: Aufzählung <code>Coin</code>, bei der die Variante
<code>Quarter</code> zusätzlich einen <code>UsState</code>-Wert enthält</span></p>
<p>Stellen wir uns vor, dass ein Freund von uns versucht, 25-Cent-Münzen aller 50
Staaten zu sammeln. Während wir unser Kleingeld nach Münzsorten sortieren,
geben wir auch den Namen des Staates der 25-Cent-Münze aus, sodass es unser
Freund in seine Sammlung aufnehmen kann, falls er es nicht hat. Im
<code>match</code>-Ausdruck für diesen Code fügen wir zum Muster der Variante
<code>Coin::Quarter</code> eine Variable <code>state</code> hinzu. Wenn der Zweig für <code>Coin::Quarter</code>
passt, wird die Variable <code>state</code> an den Wert der Eigenschaft der 25-Cent-Münze
gebunden. Dann können wir <code>state</code> im Code für diesen Zweig etwa so verwenden:</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">#[derive(Debug)] // um den Staat mit println! ausgeben zu können
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --abschneiden--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!(&quot;25-Cent-Münze aus {:?}!&quot;, state);
            25
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    value_in_cents(Coin::Quarter(UsState::Alaska));
</span><span class="boring">}
</span></code></pre></pre>
<p>Wenn wir <code>value_in_cents(Coin::Quarter(UsState::Alaska))</code> aufrufen würden,
hätte <code>coin</code> den Wert <code>Coin::Quarter(UsState::Alaska)</code>. Gleichen wir den Wert
mit jedem der <code>match</code>-Zweige ab, passt keiner von ihnen, bis wir
<code>Coin::Quarter(state)</code> erreichen. An diesem Punkt wird <code>state</code> an den Wert
<code>UsState::Alaska</code> gebunden. Wir können dann diese Bindung im
<code>println!</code>-Ausdruck verwenden und so den inneren Zustandswert aus der
<code>Coin</code>-Aufzählungsvariante für <code>Quarter</code> herausholen.</p>
<h3><a class="header" href="#abgleich-mit-optiont" id="abgleich-mit-optiont">Abgleich mit <code>Option&lt;T&gt;</code></a></h3>
<p>Im vorigen Abschnitt wollten wir den inneren <code>T</code>-Wert aus dem Fall <code>Some</code>
herausholen, als wir <code>Option&lt;T&gt;</code> verwendet haben. Wir können <code>Option&lt;T&gt;</code> ebenso
mit <code>match</code> handhaben, wie wir es mit der Aufzählung <code>Coin</code> getan haben! Statt
Münzen zu vergleichen, werden wir die Varianten von <code>Option&lt;T&gt;</code> vergleichen,
aber die Art und Weise, wie der <code>match</code>-Ausdruck funktioniert, bleibt die
gleiche.</p>
<p>Nehmen wir an, wir wollen eine Funktion schreiben, die eine <code>Option&lt;i32&gt;</code> nimmt
und, falls ein Wert darin enthalten ist, zu diesem Wert 1 addiert. Wenn darin
kein Wert enthalten ist, soll die Funktion den Wert <code>None</code> zurückgeben und
nicht versuchen, irgendwelche Operationen durchzuführen.</p>
<p>Diese Funktion ist dank <code>match</code> sehr einfach zu schreiben und wird wie in
Codeblock 6-5 aussehen.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 6-5: Eine Funktion, die einen <code>match</code>-Ausdruck
auf einer <code>Option&lt;i32&gt;</code> verwendet</span></p>
<p>Lass uns die erste Ausführung von <code>plus_one</code> näher betrachten. Wenn wir
<code>plus_one(five)</code> aufrufen, wird die Variable <code>x</code> im Rumpf von <code>plus_one</code> den
Wert <code>Some(5)</code> haben. Dann vergleichen wir das mit jedem <code>match</code>-Zweig.</p>
<pre><code class="language-rust ignore">None =&gt; None,
</code></pre>
<p>Der Wert <code>Some(5)</code> passt nicht zum Muster <code>None</code>, also fahren wir mit dem
nächsten Zweig fort.</p>
<pre><code class="language-rust ignore">Some(i) =&gt; Some(i + 1),
</code></pre>
<p>Passt <code>Some(5)</code> zu <code>Some(i)</code>? Aber ja, das tut es! Wir haben die gleiche
Variante. <code>i</code> bindet den in <code>Some</code> enthaltenen Wert, sodass <code>i</code> den Wert <code>5</code>
annimmt. Dann wird der Code im <code>match</code>-Zweig ausgeführt, also fügen wir 1 zum
Wert von <code>i</code> hinzu und erzeugen einen neuen <code>Some</code>-Wert mit der Summe <code>6</code>
darin.</p>
<p>Betrachten wir nun den zweiten Aufruf von <code>plus_one</code> in Codeblock 6-5, wo <code>x</code>
den Wert <code>None</code> hat. Wir betreten den <code>match</code>-Block und vergleichen mit dem
ersten Zweig.</p>
<pre><code class="language-rust ignore">None =&gt; None,
</code></pre>
<p>Er passt! Es gibt keinen Wert zum Hinzufügen, also stoppt das Programm und gibt
den Wert <code>None</code> auf der rechten Seite von <code>=&gt;</code> zurück. Da der erste Zweig
passt, werden keine anderen Zweige abgeglichen.</p>
<p>Die Kombination von <code>match</code> und Aufzählungen ist in vielen Situationen
nützlich. Du wirst dieses Muster häufig in Rust-Code sehen: <code>match</code> mit einer
Aufzählung, eine Variable an die darin enthaltenen Daten binden und dann
dazugehörenden Code ausführen. Am Anfang ist es etwas knifflig, aber wenn man
sich erst einmal daran gewöhnt hat, wird man sich wünschen, es in allen
Sprachen zu haben. Es ist durchweg ein Benutzerfavorit.</p>
<h3><a class="header" href="#abgleiche-sind-vollständig" id="abgleiche-sind-vollständig">Abgleiche sind vollständig</a></h3>
<p>Es gibt noch einen weiteren Aspekt von <code>match</code>, den wir diskutieren müssen.
Betrachte folgende Version unserer Funktion <code>plus_one</code>, die einen Fehler hat
und sich nicht kompilieren lässt:</p>
<pre><code class="language-rust ignore does_not_compile">fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        Some(i) =&gt; Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
</code></pre>
<p>Wir haben den Fall <code>None</code> nicht behandelt, daher wird dieser Code einen Fehler
verursachen. Glücklicherweise ist es ein Fehler, von dem Rust weiß, wie er
zu lösen ist. Wenn wir versuchen, diesen Code zu kompilieren, werden wir
diese Fehlermeldung bekommen:</p>
<pre><code class="language-text">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
 --&gt; src/main.rs:3:15
  |
3 |         match x {
  |               ^ pattern `None` not covered
  |
  = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms

error: aborting due to previous error

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Rust weiß, dass wir nicht alle möglichen Fälle abgedeckt haben, und es weiß
sogar, welches Muster wir vergessen haben! Abgleiche in Rust sind
<em>vollständig</em>: Wir müssen jede letzte Möglichkeit ausschöpfen, damit der Code
gültig ist! Speziell im Fall <code>Option&lt;T&gt;</code> schützt uns Rust davor, den Fall
<code>None</code> zu übersehen, und davon auszugehen, dass wir einen Wert haben, obwohl
vielleicht null vorliegt, und macht so den zuvor diskutierten Milliardenfehler
unmöglich.</p>
<h3><a class="header" href="#der-platzhalter-_" id="der-platzhalter-_">Der Platzhalter <code>_</code></a></h3>
<p>Rust hat auch ein Muster, das wir verwenden können, wenn wir nicht alle möglichen
Werte auflisten wollen. Zum Beispiel kann ein <code>u8</code> gültige Werte von 0 bis 255
haben. Wenn wir uns nur um die Werte 1, 3, 5 und 7 kümmern, wollen wir nicht 0,
2, 4, 6, 8, 9 bis hin zu 255 aufzählen müssen. Zum Glück müssen wir das nicht:
Wir können stattdessen das spezielle Muster <code>_</code> verwenden:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let some_u8_value = 0u8;
match some_u8_value {
    1 =&gt; println!(&quot;eins&quot;),
    3 =&gt; println!(&quot;drei&quot;),
    5 =&gt; println!(&quot;fünf&quot;),
    7 =&gt; println!(&quot;sieben&quot;),
    _ =&gt; (),
}
<span class="boring">}
</span></code></pre></pre>
<p>Das Muster <code>_</code> passt zu jedem Wert. Wenn wir es unter unsere anderen Zweige
setzen, wird <code>_</code> auf alle möglichen Fälle passen, die davor nicht angegeben
wurden. <code>()</code> ist nur der leere Wert, so dass im Fall <code>_</code> nichts passieren wird.
Damit können wir sagen, dass wir für alle möglichen Werte, die wir nicht vor
dem Platzhalter <code>_</code> auflisten, nichts tun wollen.</p>
<p>Der <code>match</code>-Ausdruck kann jedoch etwas wortreich sein, wenn wir uns nur um
<em>einen</em> der Fälle kümmern. Für diesen Fall bietet Rust <code>if let</code>.</p>
<p>Mehr über Muster und Abgleich findest du in <a href="ch18-00-patterns.html">Kapitel 18</a>.</p>
<h2><a class="header" href="#prägnanter-kontrollfluss-mit-if-let" id="prägnanter-kontrollfluss-mit-if-let">Prägnanter Kontrollfluss mit <code>if let</code></a></h2>
<p>Mit der Syntax <code>if let</code> kannst du <code>if</code> und <code>let</code> in einer weniger wortreichen
Weise kombinieren, um mit Werten umzugehen, die einem Muster entsprechen,
während der Rest ignoriert wird. Betrachte das Programm in Codeblock 6-6, das
auf einen <code>Option&lt;u8&gt;</code>-Wert passt, aber nur dann Code ausführen soll, wenn der
Wert 3 ist.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">let some_u8_value = Some(0u8);
</span>match some_u8_value {
    Some(3) =&gt; println!(&quot;drei&quot;),
    _ =&gt; (),
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 6-6: Eine <code>match</code>-Ausdruck, der nur dann Code
ausführt, wenn der Wert <code>Some(3)</code> ist</span></p>
<p>Wir wollen etwas bei <code>Some(3)</code> machen, aber nichts mit allen anderen
<code>Some&lt;u8&gt;</code>-Werten oder dem Wert <code>None</code>. Um den <code>match</code>-Ausdruck zu
vervollständigen, müssen wir <code>_ =&gt; ()</code> ergänzen. Nachdem wir nur eine Variante
verarbeiten, bedeutet das relativ viel Code, den wir schreiben müssen.</p>
<p>Stattdessen könnten wir dies in kürzerer Form schreiben, indem wir <code>if let</code>
verwenden. Der folgende Code verhält sich genauso wie der <code>match</code>-Ausdruck in
Codeblock 6-6:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">let some_u8_value = Some(0u8);
</span>if let Some(3) = some_u8_value {
    println!(&quot;three&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>Die Syntax <code>if let</code> nimmt ein Muster und einen Ausdruck, getrennt durch ein
Gleichheitszeichen. Sie funktioniert auf gleiche Weise wie bei <code>match</code>, wo der
Ausdruck hinter <code>match</code> angegeben wird und das Muster der erste Zweig ist.</p>
<p>Die Verwendung von <code>if let</code> bedeutet weniger Tipparbeit, weniger Einrückung und
weniger Codeanteil. Du verlierst jedoch die Prüfung auf Vollständigkeit, die
<code>match</code> erzwingt. Die Wahl zwischen <code>match</code> und <code>if let</code> hängt davon ab, was
du in der speziellen Situation machst, und davon, ob ein Gewinn an Prägnanz ein
angemessener Kompromiss für den Verlust einer Prüfung auf Vollständigkeit ist.</p>
<p>Anders gesagt kannst du dir <code>if let</code> als syntaktischen Zucker für einen
<code>match</code>-Ausdruck vorstellen, der Code nur bei Übereinstimmung mit einem Muster
ausführt und alle anderen Werte ignoriert.</p>
<p>Wir können ein <code>else</code> an ein <code>if let</code> anhängen. Der Code-Block, der zum <code>else</code>
gehört, ist der gleiche wie der Code-Block, der zum <code>_</code>-Zweig im
<code>match</code>-Ausdruck gehören würde. Erinnere dich an die Aufzählung <code>Coin</code> in
Codeblock 6-4, wo die Variante <code>Quarter</code> auch einen <code>UsState</code>-Wert enthielt.
Wenn wir alle Nicht-25-Cent-Münzen zählen wollten, während wir die Eigenschaft
der 25-Cent-Münzen ausgeben, könnten wir das mit einem <code>match</code>-Ausdruck wie
diesem tun:</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --abschneiden--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let coin = Coin::Penny;
</span>    let mut count = 0;
    match coin {
        Coin::Quarter(state) =&gt; println!(&quot;25-Cent-Münze aus {:?}!&quot;, state),
        _ =&gt; count += 1,
    }
<span class="boring">}
</span></code></pre></pre>
<p>Oder wir könnten einen Ausdruck mit <code>if let</code> und <code>else</code> wie diesen verwenden:</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --abschneiden--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let coin = Coin::Penny;
</span>    let mut count = 0;
    if let Coin::Quarter(state) = coin {
        println!(&quot;25-Cent-Münze aus {:?}!&quot;, state);
    } else {
        count += 1;
    }
<span class="boring">}
</span></code></pre></pre>
<p>Wenn du eine Situation hast, in der dein Programm über eine Logik verfügt, die
mit einem <code>match</code>-Ausdruck zu wortreich auszudrücken wäre, denke daran, dass
<code>if let</code> ebenfalls in deinem Rust-Werkzeugkasten enthalten ist.</p>
<h2><a class="header" href="#zusammenfassung-2" id="zusammenfassung-2">Zusammenfassung</a></h2>
<p>Wir haben uns damit befasst, wie man Aufzählungen verwendet, um
benutzerdefinierte Typen zu erstellen, die zu einem Satz von Aufzählungswerten
gehören können. Wir haben gezeigt, wie der Typ <code>Option&lt;T&gt;</code> der
Standardbibliothek dir dabei hilft, das Typsystem zu verwenden, um Fehler zu
vermeiden. Wenn Aufzählungswerte Daten enthalten, kannst du diese Werte mit
<code>match</code> oder <code>if let</code> extrahieren und verwenden, je nachdem, wie viele Fälle du
behandeln musst.</p>
<p>Deine Rust-Programme können nun Konzepte in deiner Domäne mit Hilfe von
Strukturen und Aufzählungen ausdrücken. Das Erstellen benutzerdefinierter Typen
zur Verwendung in deiner API gewährleistet Typsicherheit: Der Kompilierer wird
sicherstellen, dass deine Funktionen nur Werte jenes Typs erhalten, den die
Funktion erwartet.</p>
<p>Um deinen Nutzern eine gut organisierte API zur Verfügung zu stellen, die
einfach zu benutzen ist und nur genau das offenbart, was deine Nutzer
benötigen, wenden wir uns nun den Modulen von Rust zu.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="theme/ferris.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
